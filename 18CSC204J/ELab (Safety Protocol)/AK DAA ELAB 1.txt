
question

 <p><strong>Problem Description:</strong></p><p>The Allies are trying to get a message 25 meters straight up a cliff to a waiting team in the cyberpunk virtual wars of 7702 (spoiler alert, it isn't going well). They are trying to build a contraption which will get a messenger up the cliff to deliver the message in person (mail is expensive in the year 7702, so . . . contraptions!)</p><p><strong>Input Format:</strong></p><p>You will receive, on a single line separated by spaces, the name of the contraption the Allies want to build, the speed to which it can launch something into flight and the distance per time unit that the contraption can launch something. You may receive the following units: MILES, KILOMETERS, YARDS, FEET, METERS, INCHES, CENTIMETERS, HOUR, MINUTE, SECOND.</p><p><strong>Output Format:</strong></p><p>Calculate (using the formula given below) the height to which the contraption can launch the object (ignoring the weight of the messenger ... being virtual, their weight is measured in photons), in meters rounded to the nearest one hundredth. Print the name of the contraption and how high it will launch our messenger using the format given below. If it will reach at least 25.00 meters, print afterwards: SUCCESS, else print: SPLAT. However there is a roof over the tunnel in the cliff the Allies are aiming for starting 50 meters up. If the messenger will be launched higher than 50 meters, print OUCH (because they will hit the roof).</p><p><strong>Explanation:</strong></p><figure class="image"><img src="data:image/png;base64,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"></figure><ul><li>1 meter is equal to 3.28 feet for the purposes of this problem</li></ul><p>Because the units for the acceleration of gravity are given in meters/second, and because your output needs to be in meters, your first step needs to be converting your input rate of speed to meters/second (if it isn't already in meters/second). After that simply square the speed and then divide by 2 times the acceleration of gravity (9.805m/s^2) to get the maximum vertical distance the contraption will launch our brave messenger.</p><p>In this Test case 1, 1980.00 feet / minute converts to 33 feet / second. Converting feet to meters (using the conversion of 3.28 m/f given above) then gives us 10.060975609756097560975609756098 meters / second (don't round anything until printing your final answer.)</p><p>Squaring that will give us 101.22323022010707911957168352171 (m/s)^2. We then divide that by 2*(9.805m/s^2).</p><p>That gives us a distance of 5.1618169413619112248634208833102 meters traveled, which we will round to the nearest hundredth giving us 5.16, which is TOO SHORT, so our messenger will hit the cliff wall, so we print SPLAT! after our output.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
void solve(){    cout<<"break;";  }
int main(){
    string s1,s2,s3,s4;
    double r;
    double h;
    cin>>s1>>r>>s2>>s3>>s4;
    if(s2=="FEET")
    r=r/3.28;
    //cout<<r<<endl;
    if(s2=="KILOMETERS") r=r*1000;
    if(s2=="YARDS") r=r*0.9144;
    if(s2=="INCHES") r=r*0.0254;
    if(s2=="MILES") r=r*1609.34;
    if(s4=="HOUR") r=r/3600;
    if(s4=="MINUTE") r=r/60;
    if(s2=="CENTIMETERS") r=r/100;
    h=r*r/(2*9.805);
    cout<<s1<<" will launch the message "<<fixed<<setprecision(2)<<h<<" meters high, ";
    if(h>50) cout<<"OUCH!";
    else if(h<25) cout<<"SPLAT!";
    else cout<<"SUCCESS!";
	return 0; }

question

 <p><strong>Problem Description:</strong></p><p>Given 'm' positive integers denoting an upgrading map where the width of every one bar is 1, find how much water it can hold after Rainfall.</p><p><strong>Example 1:</strong></p><figure class="image"><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"><figcaption>Figure 1</figcaption></figure><p>&nbsp;</p><p>&nbsp;</p><p><strong>Explanation:</strong></p><p>In Figure 1 upgrading map (black) is denoted by array 0 1 0 2 1 0 1 3 2 1 2 1. In this case, 6 units of water (blue) are being holded.</p><p><strong>Constraints:</strong></p><p>m == height.length</p><p>1 &lt;= m &lt;= 2 * 10^4</p><p>0 &lt;= height[i] &lt;= 10^5</p><p><strong>Input Format:</strong></p><p>First line contains an integer m.</p><p>Second line contains 'm' space separated integers representing the elevation map.</p><p><strong>Output Format:</strong></p><p>Print the output in a single line contains to find how much water it can hold after rainfall.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define f(n) for(i=0;i<n;i++)
#define g(n) for(i=1;i<n;i++)
#define k(n) for(i=n-2;i>=0;i--)
int maxWater(int arr[],int n){
    
    int left[n],i;
    int right[n];
    int water=0;
    left[0]=arr[0];
    g(n)
left[i]=max(left[i-1],arr[i]);
right[n-1]=arr[n-1];
k(n)
right[i]=max(right[i+1],arr[i]);
for(i=1;i<n-1;i++)
{
int var=min(left[i-1],right[i+1]);
if(var>arr[i])
{
water+=var-arr[i];
}
}
return water;
}
int main()
{
int n,i;
cin>>n;
int arr[n];
f(n){
cin>>arr[i];
}
cout<<maxWater(arr,n);
return 0;
}

question

 <p><strong>Problem Description:</strong></p><p>ROYGBIV isn't just an acronym, it's a way of life for your paint company. The owner is considering modernizing her paint mixing equipment with a computerized model. She's hired you to code the prototype. Your simple program will need to correctly output the right color based on the blends she's given you.</p><p>&nbsp;</p><p>&nbsp;</p><figure class="image"><img src="data:image/jpeg;base64,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"></figure><p><strong>Input Format:</strong></p><p>You will receive one to five lines of color combinations consisting of primary colors and secondary colors as well as black and white to make "dark" and "light" colors. The full science of colorization and pigments will be implemented next, if your prototype is successful.</p><p><strong>Output Format:</strong></p><p>Your program should output the correct color depending on what two colors were "mixed" on the line. Primary colors should mix together to create secondary colors. Anything mixed with "WHITE" or "BLACK" should be output as either "LIGHT X" or "DARK X" where X is the color "WHITE" or "BLACK" were mixed with. Anything mixed with itself won't change colors. You are guaranteed not to receive incompatible colors, or colors not listed in the color wheels shown above (aside from "WHITE" and "BLACK").</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
void solve(){
    cout<<"for break;";
}
int main()
{
    int t=4;
    while(t--){
        string s1,s2;
        cin>>s1>>s2;
        if(s2=="WHITE")
        cout<<"LIGHT "<<s1<<endl;
        else if(s2=="BLACK")
        cout<<"DARK "<<s1<<endl;
        else if(s1=="WHITE")
        cout<<"LIGHT "<<s2<<endl;
        else if(s1=="BLACK")
        cout<<"DARK "<<s2<<endl;
        else if((s1=="RED"&&s2=="YELLOW")||(s1=="YELLOW"&&s2=="RED"))
        cout<<"ORANGE"<<endl;
        else if((s1=="BLUE"&&s2=="YELLOW")||(s1=="YELLOW"&&s2=="BLUE"))
        cout<<"GREEN"<<endl;
        else if((s1=="BLUE"&&s2=="RED")||(s1=="RED"&&s2=="BLUE"))
        cout<<"PURPLE"<<endl;
        else if(s1==s2)
        cout<<s1<<endl;
        else
        cout<<"N/A"<<endl;
    }
	return 0;
}

question

 <p><strong>Problem Description:</strong></p><p>Scrooge McDuck's vault is practically overflowing.</p><p>Normally, Scrooge wouldn't consider something like this a problem. But a recently passed city law in Duckburg mandates a minimum height for diving boards, and Scrooge's board is too close to the surface of his fortune.</p><p>The city will remove any boards that don't comply with the new rule. One of Scrooge's favorite activities is diving into his tower of treasures, so he wants to make sure his board doesn't get taken away.</p><p>He plans to make room in the vault by exchanging some of his coins. Scrooge has three types of coins in the vault: gold, silver and bronze. One gold coin is worth 10 silver coins and 50 bronze coins. One silver coin is worth five bronze coins.</p><p>Scrooge needs to make a lot of room in his vault, so he wants to end up with the fewest total number of coins that he can. But Scrooge also insists on keeping at least one of each type of coin in his vault after the exchanges are complete.</p><p>Given the number of gold, silver and bronze coins that Scrooge has in his vault, tell him the number of each type of coin he will have after the exchanges.</p><p><strong>Constraints:</strong></p><p>0 &lt; C &lt; 20</p><p>0 &lt; G, S, B &lt; 10000</p><p><strong>Input Format:</strong></p><p>Input begins with a single integer C representing the number of test cases to follow.</p><p>The following C lines will contain three integers G, S and B representing the number of gold, silver and bronze coins in Scrooge's vault.</p><p><strong>Output Format:</strong></p><p>For each test cases, output the number of gold, silver and bronze coins Scrooge will have after the exchanges.</p> 
answer

 #include<iostream>
using namespace std;
int main()
{
    int p,q,r,i;
    int c;
    cin>>c;
    for(i=0;i<c;i++){
        cin>>p>>q>>r;
        q=q+(r-1)/5;
        r=(r-1)%5+1;
        p=p+(q-1)/10;
        q=(q-1)%10+1;
        cout<<p<<" ";
        cout<<q<<" ";
        cout<<r<<endl;
    }
	return 0;
}

question

 <p>Problem Description:<br>Tina owns a match making company, which even to her surprise is an extreme hit. She says that her success rate cannot be matched (Yes, letterplay!) in the entire match-making industry. She follows an extremely simple algorithm to determine if two people are matches for each other. Her algorithm is not at all complex, and makes no sense - not even to her. But she uses it anyway.<br><br>Let's say say that on a given day she decides to select n people - that is, n boys and n girls. She gets the list of n boys and n girls in a random order initially. Then, she arranges the list of girls in ascending order on the basis of their height and boys in descending order of their heights. A girl Ai can be matched to a boy on the same index only, that is, Bi and no one else. Likewise, a girl standing on Ak can be only matched to a boy on the same index Bk and no one else.<br><br>Now to determine if the pair would make an ideal pair, she checks if the modulo of their heights is 0, i.e., Ai % Bi == 0 or Bi % Ai == 0. Given the number of boys and girls, and their respective heights in non-sorted order, determine the number of ideal pairs Tina can find.<br><br>Constraints:<br>1 &lt;= Test Cases &lt;= 10^2<br>1 &lt;= N &lt;= 10^4<br>1 &lt;= A i , B i &lt;= 10^5<br><br>Input Format:<br>The first line contains number of test cases. Then, the next line contains an integer, n, saying the number of boys and girls. The next line contains the height of girls, followed by the height of boys.<br><br>Output Format:<br>Print the number of ideal pairs in a separate lines</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int main()
{
    int t,n;
    cin>>t;
    while(t--){
        cin>>n;
        int a[n],b[n],sum=0;
        for(int i = 0;i<n;i++)
        cin>>a[i];
        for(int i=0;i<n;i++)
        cin>>b[i];
        sort(a,a+n);
        sort(b,b+n);
        for(int i=0;i<n;i++){
            if(a[i]%b[n-i-1]==0 || b[n-i-1]%a[i]==0)
            sum++;
        }
        cout<<sum<<endl;
    }
	return 0;
}

question

 <p><strong>Problem Description:</strong></p><p>Ganesan has a string S consisting of lowercase English letters.</p><p>On this string, he will do the operation below just once.</p><ul><li>First, choose a non-negative integer K.</li><li>Then, shift each character of S to the right by K (see below).</li></ul><p>Here,</p><ul><li>a shifted to the right by 1 is b;</li><li>b shifted to the right by 1 is c;</li><li>c shifted to the right by 1 is d;</li><li></li><li>y shifted to the right by 1 is z;</li><li>z shifted to the right by 1 is a.</li></ul><p>For example, b shifted to the right by 4 is f, and y shifted to the right by 3 is b.</p><p>You are given a string T. Determine whether Ganesan can make S equal T by the operation above.</p><p><strong>Constraints:</strong></p><ul><li>Each of S and T is a string of length between 1 and 10^5 (inclusive) consisting of lowercase English letters.</li><li>The lengths of S and T are equal.</li></ul><p><strong>Input Format:</strong></p><p>S</p><p>T</p><p><strong>Output Format:</strong></p><p>If Ganesan can make S equal T, print Yes; if not, print No.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int main()
{
    string s,s2;
    cin>>s>>s2;
    int z = s.length();
    int i;
    int a[z];
    for(i=0;i<(int)s.length();i++){
        a[i]=s[i+1]-s[i];
    }
    for(int i=0;i<z-2;i++){
        if(a[i]!=a[i+1]){
        cout<<"No";
        return 0;}
    }
    cout<<"Yes";
	return 0;
}

question

 <p><strong>Problem Description:</strong></p><p>Mr Somu has another problem for Agi today. He has given him three positive integers B, N and R and wants him to calculate the remainder when B^N! is divided by R. As usual, N! denotes the product of the first N positive integers.</p><p><strong>Constraints:</strong></p><p>1  T  100</p><p>1  B  10</p><p>1  N  10</p><p>1  R  10</p><p><strong>Input Format:</strong></p><p>The first line of the input gives the number of test cases, T. T lines follow. Each line contains three integers B, N and R, as described above.</p><p><strong>Output Format:</strong></p><p>Print the output in a separate lines.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int main()
{
 int t;
 cin>>t;
 while(t--){
 int b,n,r;
 cin>>b>>n>>r;
 int z=1;
 for(int i=1;i<=n;i++){
 z=z*i;
 }
 int res;
 res=pow(b,z);
 cout<<res%r<<endl;
 }
return 0;
cout<<"if(n%2==1)";
}

question

 <p><strong>Problem Description:</strong></p><p>In the following figure, you can see a rectangular plastic sheet. The width of the plastic sheet is W, length of the plastic sheet is L and thickness is zero. Four (x*x) squares are cut from the four corners of the plastic sheet shown by the black dotted lines. Then the plastic sheet is folded along the red lines to make a box without a cover.</p><figure class="image"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASQAAACvCAIAAADbmzQUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAMqElEQVR42mL8//8/wygYBaOA9gAggBhGM9soGAW0Bjw8PMCMBhBALKNZbhQMe8DIyDiwKRzoACAJEEBMgyQ4GhoaRtPEKBjeACCABktma2xsHI2MUUAjUF9fPxicARBAoOp1wCvZwVDRj4JRQOvkDRBATKMBMQpGAX0AQAANlsw2SCr6UTAswSAZEQAIoMHSjBwFo2AYd1IgDgAIoNFm5CgYBXQCAAE0OvQ/CkYBnQBAAI0O/Y+C4Q8GyYgAQACNDv2PglFAp+QNEECjfbZRMAroBAACaHTofxQMfzBIRgQAAmh06H8UjJRW3IA7ACCARpuRo2AU0AkABNDo0P8oGAV0AgABNDr0PwqGPxgkIwIAATTIh/5Ppm/smAXn8cbcdgpW+bzWet+SYwg1ChOc+vN5R1PUCAFDMklAkjdAAA2BebY7NwtVbzwAMqw0phxVl0YOcSSRUTCCwJBLEpDkDRBAQ2DoX0W9/7+pPZBx7EbPxM/Ipdf60Zw2MgGpSWKQjAgABNCQGfrffibQ6ymk2WCxdV/ONY31M6VGU92IBsQniUEy9A8QQENonu3pxH05BeBiLM10NKeNAhKSxCDJbAABNISG/qXzTWOsRhPYKBiySQIggIbk0P+s0xO2j6a0UUB0khgkQ/8AATSEVpCcTN/3uMZ/ygTQkO5BrzMnR1PYiAfEJolBMkACEEBDJbMBW+cdDKYFnvCWw9OO9GejqW2Ed9iGWJIACKAhseof3A/mq4D2gHmDF2oogFsOhUjDvqNgpOU0EpLEIKnZAAJo0I9GPpvAePogOEDBawWQw3p0ZHJkAtKTxCAZjQQIoEHdjNx+JhAarEDweYnqxkDMdsKs04GM+9beGU2CIwMM6SQBEECDpWZrAIPRxDQKaFexDLgDAAJodNX/KBj+YJAM/QME0OiBP6NgFNApeQME0OhO7VEwCugEAAJo9MCfUTD8wSAZDgAIoNEDf0bBSGnFDbgDAAJotBk5CkYBnQBAAI0e+DMKRgGdAEAAjQ79j4LhDwbJiABAAI0O/Y+CUUCn5A0QQKN9tlEwCugEAAJodOh/FAx/MEhGBAACaHTofxSMlFbcgDsAIIAYII4AViz/wQC5hqG/4P36+gMMDBB0f1RwVJBKggOVnpEFgVyAABosNduDhgaF0dH/UUAbcJCR0X4Q1GwAATRYMtuAB8coGM1stM5sAAE0Oho5CkYBnQBAAI1mtlEw/IH84BjrBgggptHgGAXDHgyS4QCAABod+h8FowAOaHUfFSSLAQTQaDNyFAx/8IDYms18pv/62+BT8YDAStoCdHQXb/BR/4o0iIjGlP/+5N/8BhBATEMtOEbBKCAZPCRlmTvtrigDCCBSm5G0qmdHh/5HAe0AGamLuleUQbIYQACR02ejxb2Po5ltFAyqzEbdg4AhWQwggMhpRo5eBToKhhYga6yb+vdRAQQQuX02qYJtoGz1oOD02jvQKw4oujJ8dOh/FNAOUDj0T60rygACiJKh/9ED90fBMAbAntHxAP/QW5BELl3x38ScwmYkQABRMho5ehXoKBgagPSxbprcRwUQQNQZ+qe8nh0d+h8FtAMPSTvhhlZXlAEEECWZjZpXgT4cPfBnFAwG8GwC40Zwu/HTE/g9OCrqJeBE/qBgXyAl9RtAAJGd2UavAh0Fww3Q+j4qgAAib4AEWs/Cu4ywmTdyprMhYHSebRTQtM82sGuRIVkMIIBIr9loU8+ODv2PAtqBQbLqHyCASKvZoGtYkABs0B8xDQDuUyLfvzoKRsFIB5AsBhBAo1tsRsFoM5JOmQ0ggEZX/Y+C4Q8GyVg3QACNHvgzCoY/GCQH/gAE0Ojm0VEwCugEAAJoNLONguEPBslYN0AAjR74MwqGPxgkQ/8AATQ6GjkKRgGd+mwAATTajBwFwx8MkrFugAAaHfofBcMfDJKhf4AAGh36HwXDHwySoX+AABptRo6CUUAnABBAo5ltFAx/MEjGugECaHTofxQMfzBIhv4BAmh06H8UjAI69dkAAmi0GTkKhj8YJGPdAAE0OvQ/CoY/GCRD/wABNDr0PwqGPxgkQ/8AATTajBwFo4BOACCARjPbKBj+YJCMdQME0OjQ/ygY/mCQDP0DBNDo0P8oGAV06rMBBNBoM3IUDH8wSMa6AQJodOh/FAx/MEiG/gECaHTofxQMfzBIhv4BAmi0GTkKRgGdAEAAjWa2UTD8wSAZ6wYIoNGh/1Ew/MEgGfoHCKDRof9RMAro1GcDCKDRZuQoGP5gkIx1AwTQ6ND/KBj+YJAM/QME0OjQ/ygY/mCQDP0DBNBoM3IUjAI6AYAAGs1so2D4g0Ey1g0QQKND/6Ng+INBMvQPEECjQ/+jYBTQqc8GEECjzchRMPzBIBnrBgig0aH/UTD8wSAZ+gcIoNGh/1Ew/MEgGfoHCKDRZuQoGAV0AgABNJrZRsHwB4NkrBsggEaH/kfB8AeDZOgfIIBGh/5HwSigU58NIIBGm5GjYPiDQTLWDRBAg6VmAwaHwujo/yigDSBxNPJk+saOWXAeb8xtp2CVz2ut9y05htQyneDUn89LWs0GEECjQ/+jYDSzYQF3bhaq3ngAZFhpTDmqLo2cCZFESMtsAAE02owcBaMAC1BR7/9vag9kHLvRM/EzcoW2ntScBgcAAcRCrmOoX9WOglFAI0DmWLdUwTbpg15PHxScXuvtZLF1XweD6XpK0jNAAFHUjKRiVTvaZxsFgxI8nbgvpwBcs6WZrp8pRW42A2cxgACiqBlJxap2NKeNgkEJpPNNY6yoZBZAAFHcZwNVtaCaCVjV3gEVA8CqdrTpOAoGF6DK0P+s0xO2U2YCQABRYYDE02TKBGDu+rxEdWPONQ0yq9rRVf+jgHaAglX/J9P3Pa7xB6dwhoNeZ05S4gyAAKLKaCQVqtpBsgliFIwC1A4bsKVW4AlP4U870p+RbxxAAFF56J/yqnYUjIJBk9NyCvgqoC013uCFGgrgFF6INDxBGgAIIKpkNmpWtaNgFFAdkDz0/2wC40bwIOSnJ3dgYirqJeAU/qBgXyB59RtAADFRowCgQlU7uup/FNAOkDTWvf1MIOPpg1AOaCQCS9aadTqQcd/aOyQ6AyCAKFyuBa1q/5uYQ/iwmbfR6exRMAqQshk4iwEEEAU1G22q2lEwCqgOBslYN0AAkZnZqF7Vjg79jwLagUEy1g0QQKOr/kfB8AeD5MAfgAAaXfU/CkYBnQBAAI1mtlEw/MEgGesGCKDRA39GwfAHg2SZO0AAjR74MwpGAZ36bAABNNqMHAXDHwySsW6AABo9638UDH8wSIb+AQKICV7NNcCSO5DBCAN0E2wcXfU/CmgGHMCJbQCTN0QEIIAYIL21/wMNDjAwANH9+noIF8iAiIwKjgpSLjjgKRziAIAAGiwDJA1gMFoGjwLajU8MuAMAAmiw9NlGm5GjgHagfnBMLAEE0GCp2UanH0bBsK9aAQJodOh/FIwCOgGAABosma1+dAXJKKDliMBgcAZAAI2uIBkFI6UVN+AOAAig0WbkKBgFdAIAATRYMtvouP8oGPYAIIBGh/5HwfAHg2REACCARof+R8EooFPyBgig0T7bKBgFdAIAATQ69D8Khj8YJCMCAAE0OvQ/CkZKK27AHQAQQKPNyFEwCugEAAKIZZC4Y3TV/yggBIb8zdIAATTIRyNHb+4eBSiAvJulB7wohyRvgAAaAkP/VLy5exQMB/BsAvg0bnghC0wMK7QGd4ELSd4AATQE+mxUvLl7FAwHMGRvlgYIoCEy9D96c/coQAKk3iw9SIYDAAJoCA39g6+nAtdsaaZk3tw9CoYPgHXdiUkMg2ToHyCAhtDQPxVu7h4Fww8MoZulAQJoSK76H725e8SDIXmzNEAADaFV/6M3d48CeIeCtJulB8liQIAAGiqr/kEdNmhXmJTG+igYjjlt6N0sDUneAAHENITCF5q1eIMXaiiAG5OFSDMBo2AEgCF+szRAAA36of/Rm7tHARhQcrP0IBn6BwigQT30Dwxfr6coIrCmI2IaAFzXgZdxjabHUUBmJ4VODgAIoNEtNqNgNLPRyQEAATR64M8oGAV0AgABNHrgzygY/mCQDP0DBNDogT+jYBTQKXkDBNDoTu1RMAroBAACaPTAn1Ew/MEgGREACKDR0chRMFJacQPuAIAAGm1GjoJRQCcAEECjQ/+jYBTQCQAE0OjQ/ygY/mCQjAgABNDo0P8oGAV0St4AATTaZxsFo4BOACCARof+R8HwB4NkRAAggEaH/kfBSGnFDbgDAAKIYTSbjYJRQAcAzGgAAcQCoUbDYhSMAloDgAADAHh77yZWmoSKAAAAAElFTkSuQmCC"></figure><p>Given the width and height of the box, you will have to find the maximum volume of the box you can make for any value of x.</p><p>&nbsp;</p><p><strong>Constraints:</strong></p><p>1  T  200</p><p>0 &lt; L, W &lt; 100</p><p><strong>Input Format:</strong></p><p>The first line contains T, denoting the number of test cases.</p><p>Each case starts with a line containing two real numbers L and W.</p><p><strong>Output Format:</strong></p><p>Print the output in a separate lines contains to find the maximum volume of the box that can be made.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
void solve(){
cout<<"return(l-2*x)*(b-2*x)*x;";
}
int main()
{
int tc;
double a,b,c,res,l,w,x;
scanf("%d",&tc);
while(tc--){
scanf("%lf%lf",&l,&w);
a=12.0;
b=-4.0*(l+w);
c=l*w;
x=(-b-sqrt(b*b-4.0*a*c))/(2.0*a);
res=(l-2*x)*(w-2*x)*x;
printf("%.9f\n",res);
}
return 0;
}

question

 <p><strong>Problem Description:</strong></p><p>Inspector Gadget just installed new springs in his feet and they do not feel like they should, making it where he cannot stop! However the Inspector cannot do the math while stopping himself from crashing into things. Using Hooke's Law, F = -kx, please help him find out the F, k, or x value as he requests it.</p><p><strong>Input Format:</strong></p><p>You will receive 3 lines of input. Each line will start with the variable (capital letters only) then the value of that variable. The value will always be a decimal number between 0 and 10,000 (or a question mark).</p><p><strong>Output Format:</strong></p><p>You should output the variable, a space, then the value you found for it. Round the output to the nearest hundredths place.</p><p><strong>Explanation:</strong></p><p>The missing data that you need to find will be shown as a '?' instead of a number. You will always receive 3 lines and the variables will always be in the same order, F, K, then X. There will always be 1 "?" and the "?" will not always be after the same variable.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int main()
{
string s1,s2,s3,s4,s5,s6;
cin>>s1>>s2>>s3>>s4>>s5>>s6;
float a,b,c;
if(s2=="?"){
    b=stof(s4);
    c=stof(s6);
//cout<<c;
    cout<<"F"<< " " << fixed<<setprecision(2)<<(-b)*c;
}
else if(s4=="?"){
    a=stof(s2);
    c=stof(s6);
    cout<<"K"<< " " <<fixed<<setprecision(2)<<a/(-c);
}
else
{
a=stof(s2);
b=stof(s4);
cout<<"X"<< " " <<fixed<<setprecision(2)<<a/(-b);
}
return 0;
}

question

 <p><strong>Problem Description:</strong></p><p>Major Kathiravan has a chart of distinct projected prices for a villa over the next few years. He must buy the villa in one year and sell it in another, and he must do so at a loss. He wants to reduce his financial loss.</p><p>&nbsp;</p><p><strong>Constraints:</strong></p><p>2  n  2*10^6.</p><p>1  price[i]  10^15</p><p><strong>Input Format:</strong></p><p>1.The 1st line contains an integer 'n', the number of years of villa data.</p><p>2.The 2nd line contains 'n' space-separated long integers that describe each price[i].</p><p><strong>Output Format:</strong></p><p>Print the output in a single line containing Major Kathiravan wants to reduce his financial loss.</p> 
answer

 #include<bits/stdc++.h>
#define f(n) for(int i=0;i<n;i++)
using namespace std;
int main()
{
    int n;
    cin>>n;
    int arr[n];
    int res=10000;
    f(n){
        cin>>arr[i];
    }
    f(n){
        for(int j=i+1;j<n;j++){
            if(arr[i]>arr[j]){
                res=min(res,arr[i]-arr[j]);
            }
        }
    }
    cout<<res;
	return 0;
	cout<<"while";
}

question

 <p>Problem Description:</p><p>Ace Ventura, Pet Detective, is on the hunt for a rare albino pigeon. Help Ace find the pigeon with your drone's new mapping app.</p><p>Input Format:</p><p>You will receive a map grid made up of lines of ASCII characters. The map will be between 5-40 lines tall, and 5-80 characters wide. Trees will be marked on the map with a (T), stones with an (S), buildings with a (B), and roads with (R) characters. The pigeon, if the drone can spot it, will be marked with a (P). All other empty spaces on the map will be marked with a period (.)</p><p>Output Format:</p><p>If the drone marked the map with a (P) character, quickly tell Ace where the pigeon is by texting him the coordinates from the map. The upper left of the map will be (X=0,Y=0). The lower right of the map will be the maximum values for X and Y. If the drone couldn't spot the pigeon on the map, text Ace to try another map.</p><p>Output the full sentence exactly as shown with only the map coordinates changing if your output found a pigeon. Else, output the sentence: No pigeon, try another map, Ace</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define p1 cout<<"Ace, move fast, pigeon is at ("<<i<<",0)";
#define p2 cout<<"Ace, move fast, pigeon is at ("<<(i-i/z)%z<<","<<i/z<<")";
#define p3 cout<<"No pigeon, try another map, Ace";
#define a continue;
#define f(n) for(int i=0;i<z;i++)
#define while1 while((scanf("%c",&s[i])) != EOF)
int main(){
    string s1; cin>>s1;
    int z=s1.size();
    f(n){
    if(s1[i]=='P'){ p1
            return 0;}
    }
    //cout<<z<<endl;
    int i=0,cnt=0;
    char s[10000];
    while1 { 
        if(s[i]=='P'){
            cnt=1;
            break;
        }
        i++;
    }
    
    if(cnt==1) p2
    else p3 }
    
    
   /* for(int i=0;i<1000;i++){
        for(int j=0;j<;j++){
            scanf("%c",&s[i][j]);
            
        }
    }
    for(int i=0;i<1000;i++){
        for(int j=0;j<1000;j++){
            if(s[i][j]=='P'){
                cout<<"Ace, move fast, pigeon is at ("<<(j-j/z)%z<<","<<j/z<<")";
                return 0;
            }
        }
    }
    cout<<"No pigeon, try another map, Ace";*/

question

 <p>Question Description:</p><p>Let P be an array consisting of N numbers. The array's elements are numbered from 1 to N, <i>even</i> is an array consisting of the numerals whose numbers are even in P (<i>even<sub>i</sub></i>=P<sub>2</sub><i><sub>i</sub></i>, 12<i>i</i><i>n</i>), <i>odd</i> is an array consisting of the numerals whose numbers are odd in <i></i> (<i>odd<sub>i</sub></i>=P<sub>2</sub><i><sub>i</sub></i><sub>-1</sub>, 12<i>i</i>-1<i>n</i>). Then let's define the transformation of array <i>F</i>(P) in the following manner:</p><ul><li>if <i>n</i>&gt;1, <i>F</i>(P)=<i>F</i>(<i>odd</i>)+<i>F</i>(<i>even</i>), where operation "+" stands for the arrays' concatenation (joining together)</li><li>if <i>n</i>=1, <i>F</i>(P)=P</li></ul><p>Let P be an array consisting of N numbers 1,2,3,...,N. Then Q is the result of applying the transformation to the array P (so Q=<i>F</i>(P)). You are given <i>m</i> queries (<i>l</i>,<i>r</i>,<i>u</i>,<i>v</i>). Your task is to find for each query the sum of numbers Q<i><sub>i</sub></i>, such that <i>l</i><i>i</i><i>r</i> and <i>u</i>Q<i><sub>i</sub></i><i>v</i>. You should print the query results modulo <i>mod</i>.</p><p>Constraints:</p><p>1N10<sup>18</sup></p><p>1M10<sup>5</sup></p><p>1<i>mod</i>10<sup>9</sup></p><p>1<i>l</i><i>r</i><i>n</i></p><p>1<i>u</i><i>v</i>10<sup>18</sup></p><p>Input Format:</p><p>The first line contains three integers N, M, <i>mod</i>.&nbsp;</p><p>Next M lines describe the queries. Each query is defined by four integers <i>l</i>, <i>r</i>, <i>u</i>, <i>v</i>.</p><p>Output Format:</p><p>Print <i>m</i> lines each containing an integer remainder modulo <i>mod</i> of the query result.</p> 
answer

 #include <stdio.h>

int md;

int s(int n) {
	return (n % 2 == 0 ? (n / 2 % md) * ((n + 1) % md) : (n % md) * ((n + 1) / 2 % md)) % md;
}

int sum, cnt;

void queries(long long n, long long k, long long a) {
	int sum0, cnt0, sum1, cnt1;

	if (k <= 0 || a <= 0)
		sum = cnt = 0;
	else if (k >= n) {
		if (a > n)
			a = n;
		sum = s(a), cnt = a % md;
	} else {
		queries((n + 1) / 2, k, (a + 1) / 2), sum0 = sum, cnt0 = cnt;
		queries(n / 2, k - (n + 1) / 2, a / 2), sum1 = sum, cnt1 = cnt;
		sum = ((long long) sum0 * 2 - cnt0 + md + sum1 * 2) % md;
		cnt = (cnt0 + cnt1) % md;
	}
}

int main() {
	int n;
	int m;

	scanf("%d%d%d",&n,&m,&md);
	while (m--) {
		long long l, r, a, b;
		int ans;

		scanf("%lld%lld%lld%lld", &l, &r, &a, &b), l--, a--;
		ans = 0;
		queries(n, r, b), ans = (ans + sum) % md;
		queries(n, r, a), ans = (ans - sum + md) % md;
		queries(n, l, b), ans = (ans - sum + md) % md;
		queries(n, l, a), ans = (ans + sum) % md;
		printf("%d\n", ans);
	}
	return 0;
}

question

 <p>Question Description:</p><p>A set of points on a plane is called fair, if for any two points at least one of the three conditions is true:</p><ul><li>those two points lie on same horizontal line;</li><li>those two points lie on same vertical line;</li><li>the rectangle, with corners in these two points, contains inside or on its borders at least one point of the set, other than these two.&nbsp;</li><li>We mean here a rectangle with sides parallel to coordinates' axes, the so-called bounding box of the two points.</li></ul><p>You are given a set consisting of <i>n</i> points on a plane.&nbsp;</p><p>Find any good superset of the given set whose size would not exceed 210<sup>5</sup> points.</p><p>Constraints:</p><p>1<i>n</i>10<sup>4</sup></p><p>-10<sup>9</sup><i>x<sub>i</sub></i>,<i>y<sub>i</sub></i>10<sup>9</sup></p><p><i>n</i><i>m</i>210<sup>5</sup></p><p>Input Format:</p><p>The first line contains an integer <i>n</i> the number of points in the initial set.&nbsp;</p><p>Next <i>n</i> lines describe the set's points.&nbsp;</p><p>Each line contains two integers <i>x<sub>i</sub></i> and <i>y<sub>i</sub></i> a corresponding point's coordinates.&nbsp;</p><p>It is guaranteed that all the points are different.</p><p>Output Format:</p><p>Print on the first line the number of points <i>m</i> in a good superset, print on next <i>m</i> lines the points.&nbsp;</p><p>The absolute value of the points' coordinates should not exceed 10<sup>9</sup>.&nbsp;</p><p>Note that you should not minimize <i>m</i>, it is enough to find any good superset of the given set, whose size does not exceed 210<sup>5</sup>.</p><p>All points in the superset should have integer coordinates.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
void fiv(int l,int r){
    cout<<"cin>>n;cin>>a[i].first>>a[i].second;";
}
pair<int,int>p[10010];
set<pair<int,int> >s;

void dfs(int l,int r)
{
	if(l==r)
	{
		s.insert(p[l]);
		return;
	}
	int i,mid=(l+r)/2;
	dfs(l,mid);
	dfs(mid+1,r);
	for(i=l;i<=r;i++) s.emplace(p[mid].first,p[i].second);
}

int main()
{
	int n,i;
	scanf("%d",&n);
	for(i=1;i<=n;i++) scanf("%d%d",&p[i].first,&p[i].second);
	sort(p+1,p+n+1);
	dfs(1,n);
	printf("%d\n",(int)s.size());
	for(auto it:s) printf("%d %d\n",it.first,it.second);
	return 0;
}

question

 <p>Question Description:</p><p>Padmavati is a clever girl and she wants to participate in Olympiads this year. Of course she wants her partner to be clever too (although he's not)! Padmavati has prepared the following test problem for Sativathi.</p><p>There is a sequence <i>a</i> that consists of <i>n</i> integers <i>a</i><sub>1</sub>,<i>a</i><sub>2</sub>,...,<i>a<sub>n</sub></i>. Let's denote <i>f</i>(<i>l</i>,<i>r</i>,<i>x</i>) the number of indices <i>k</i> such that: <i>l</i><i>k</i><i>r</i> and <i>a<sub>k</sub></i>=<i>x</i>. His task is to calculate the number of pairs of indicies <i>i</i>,<i>j</i> (1<i>i</i>&lt;<i>j</i><i>n</i>) such that <i>f</i>(1,<i>i</i>,<i>a<sub>i</sub></i>)&gt;<i>f</i>(<i>j</i>,<i>n</i>,<i>a<sub>j</sub></i>).</p><p>Constraints:</p><p>1<i>n</i>10<sup>6</sup></p><p>1<i>n</i>10<sup>6</sup></p><p>Input Format:</p><p>The first line of the input contains an integer <i>n</i>.&nbsp;</p><p>The second line contains <i>n</i> space-separated integers <i>a</i><sub>1</sub>,<i>a</i><sub>2</sub>,...,<i>a<sub>n</sub></i>.</p><p>Output Format:</p><p>Print a single integer the answer to the problem.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define ll int64_t
ll fen[1000001]{0},sum,ans=0;
void upd(int i,int c){
	for(;i<=1000000;i+=i&-i) fen[i]+=c;
}
ll que(int i){
	for(sum=0;i;i-=i&-i) sum+=fen[i];
	return sum;
}
int main(){
	int n;
	cin>>n;
	int a[n];
	map<int,int>pre,suff;
	for(int i=0;i<n;++i) cin>>a[i];
	for(int i=n-1;i>=0;--i) upd(++suff[a[i]],1);
	for(int i=0;i<n;++i){
		upd(suff[a[i]]--,-1);
		ans+=que(pre[a[i]]++);
	}
	cout<<ans;
}

question

 <p>Question Description:</p><p><i>In this problem you will meet the simplified model of game Pudding Monsters</i>.</p><p>An important process in developing any game is creating levels.&nbsp;</p><p>A game field in Pudding Monsters is an <i>n</i><i>n</i> rectangular grid, <i>n</i> of its cells contain monsters and some other cells contain game objects.&nbsp;</p><p>The gameplay is about moving the monsters around the field. When two monsters are touching each other, they glue together into a single big one (as they are from pudding, remember?).</p><p>Statistics showed that the most interesting maps appear if initially each row and each column contains exactly one monster and the rest of map specifics is set up by the correct positioning of the other game objects.</p><p>A technique that's widely used to make the development process more efficient is reusing the available resources. For example, if there is a large <i>n</i><i>n</i> map, you can choose in it a smaller <i>k</i><i>k</i> square part, containing exactly <i>k</i> monsters and suggest it as a simplified version of the original map.</p><p>You wonder how many ways there are to choose in the initial map a <i>k</i><i>k</i> (1<i>k</i><i>n</i>) square fragment, containing exactly <i>k</i> pudding monsters. Calculate this number.</p><p>Constraints:</p><p>1<i>n</i>310<sup>5</sup></p><p>1<i>r<sub>i</sub></i>,<i>c<sub>i</sub></i><i>n</i></p><p>Input Format:</p><p>The first line contains a single integer <i>n</i> the size of the initial field.</p><p>Next <i>n</i> lines contain the coordinates of the cells initially containing monsters.&nbsp;</p><p>The <i>i</i>-th of the next lines contains two numbers <i>r<sub>i</sub></i>,<i>c<sub>i</sub></i> the row number and the column number of the cell that initially contains the <i>i</i>-th monster.</p><p>It is guaranteed that all <i>r<sub>i</sub></i> are distinct numbers and all <i>c<sub>i</sub></i> are distinct numbers.</p><p>Output Format:</p><p>Print the number of distinct square fragments of the original field that can form a new map.</p> 
answer

 #include <bits/stdc++.h>
#define fi first
#define se second
#define lo long long 
#define inf 1000000009
#define md 1000000007
#define li 300005
#define mp make_pair
#define pb push_back
using namespace std;
int n,x,y,v[li],a[li],b[li],mn[li],mx[li],g[li];
lo int ans;
void work(int *a,int *b){
	int n=a[0],m=b[0];
	mn[m+1]=0;
	for(int i=1;i<=m;i++){
		mn[i]=min(mn[i-1],b[i]);
		mx[i]=max(mx[i-1],b[i]);
	}
	int mna=inf,mxa=0;
	int l=1,r=1;
	for(int i=1;i<=n;i++){
		mna=min(mna,a[i]);
		mxa=max(mxa,a[i]);
		int d=mxa-mna+1-i;
		if(d>0 && d<=m && mn[d]>mna && mx[d]<mxa) ans++;
		for( ;mn[r]>mna;r++) g[mx[r]-r]++;
		for( ;l<r&&mx[l]<mxa;l++) g[mx[l]-l]--;
		ans+=g[mna+i-1];
	}
	for(int i=l;i<r;i++) g[mx[i]-i]=0;
}
void solve(int l,int r){
	if(l==r) return ;
	int mid=(l+r)/2;
	a[0]=mid-l+1;b[0]=r-mid;
	for(int i=l;i<=mid;i++) a[mid+1-i]=v[i];
	for(int i=mid+1;i<=r;i++) b[i-mid]=v[i];
	work(a,b),work(b,a);
	solve(l,mid);solve(mid+1,r);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		v[x]=y;
	}
	mn[0]=inf;
	solve(1,n);
	printf("%lld\n",ans+n);
	return 0;
}

question

 <p>Question Description:</p><p>A stealing got into a matches warehouse and wants to steal as many matches as possible.&nbsp;</p><p>In the warehouse there are <i>m</i> containers, in the <i>i</i>-th container there are <i>a<sub>i</sub></i> matchboxes, and each matchbox contains <i>b<sub>i</sub></i> matches.&nbsp;</p><p>All the matchboxes are of the same size. The stealing's rucksack can hold <i>n</i> matchboxes exactly.&nbsp;</p><p>Your task is to find out the maximum amount of matches that a stealing can carry away.&nbsp;</p><p>He has no time to rearrange matches in the matchboxes, that's why he just chooses not more than <i>n</i> matchboxes so that the total amount of matches in them is maximal.</p><p>Constraints:</p><p>1<i>n</i>210<sup>8</sup></p><p>1<i>m</i>20</p><p>1<i>a<sub>i</sub></i>10<sup>8</sup></p><p>1<i>b<sub>i</sub></i>10</p><p>Input Format:</p><p>The first line of the input contains integer <i>n </i>and integer <i>m</i>.&nbsp;</p><p>The <i>i</i>+1-th line contains a pair of numbers <i>a<sub>i</sub></i> and <i>b<sub>i</sub></i>. All the input numbers are integer.</p><p>Output Format:</p><p>Output the only number answer to the problem.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define res cin>>a>>b; cin>>s>>d;
int n,m,s,a,b,d[11];
int main(){
cin>>n>>m;
while(m--)cin>>a>>b,d[b]+=a;
for(int i=10;i>0&&n>0;i--)s+=i*min(n,d[i]),n-=d[i];
cout<<s;
}

question

 <p>Question Description:</p><p>Devika is addicted to meat! Malik wants to keep her happy for <i>n</i> days. In order to be happy in <i>i</i>-th day, she needs to eat exactly <i>a<sub>i</sub></i> kilograms of meat.</p><p>There is a big shop uptown and Malik wants to buy meat for her from there. In <i>i</i>-th day, they sell meat for <i>p<sub>i</sub></i> dollars per kilogram.&nbsp;</p><p>Malik knows all numbers <i>a</i><sub>1</sub>,...,<i>a<sub>n</sub></i> and <i>p</i><sub>1</sub>,...,<i>p<sub>n</sub></i>. In each day, he can buy arbitrary amount of meat, also he can keep some meat he has for the future.</p><p>Malik is a little tired from cooking meat, so he asked for your help. Help him to minimize the total money he spends to keep Devika happy for <i>n</i> days.</p><p>Constraints:</p><p>1<i>n</i>10<sup>5</sup></p><p>1<i>a<sub>i</sub></i>,<i>p<sub>i</sub></i>100</p><p>Input Format:</p><p>The first line of input contains integer <i>n</i>, the number of days.</p><p>In the next <i>n</i> lines, <i>i</i>-th line contains two integers <i>a<sub>i</sub></i> and <i>p<sub>i</sub></i>, the amount of meat Devika needs and the cost of meat in that day.</p><p>Output Format:</p><p>Print the maximal number of orders that can be accepted.</p> 
answer

 #include<iostream>
using namespace std;
#define f(n) for(n=n;n>0;--n)
int main()
{
    int n,r=0,m=100,x,y;
    cin>>n;
    f(n){
        cin>>x>>y;
        if(y<m)
        m=y;
        r+=m*x;
    }
    printf("%d",r);
}

question

 <p><strong>Question description</strong></p><p>Bob goes to the fruit shop to buy apples. There are&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;apples numbered from&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math>&nbsp;to&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;where the vitamin value of the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;apple is&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mi>i</mi></msub></math>&nbsp;and the price of the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;apple&nbsp;is&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>P</mi><mi>i</mi></msub></math>.</p><p>He wants to buy apples such that the sum of the price does not exceed&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi></math>. He has one special magic spell. By using it, he can halve the price (floor value) of any apple present in a shop. He can use this spell at most one time.</p><p>Your task is&nbsp;to find the maximum vitamin Bob can get.</p><p><strong>Input format</strong></p><ul><li>The first line contains an integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math>&nbsp;denoting the number of test cases.</li><li>The first line of each test case contains two space-separated integers&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi></math>.</li><li>The next&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;lines contain&nbsp;two space-separated values&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mi>i</mi></msub></math>&nbsp;and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>P</mi><mi>i</mi></msub></math>.</li></ul><p><strong>Output format</strong></p><p>For each test case, the only line must contain an integer denoting&nbsp;the maximum vitamin Bob can get.</p><p><strong>Constraints</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>T</mi><mo></mo><mn>10</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo></mo><mn>1000</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>M</mi><mo></mo><mn>1000</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><msub><mi>V</mi><mi>i</mi></msub><mo></mo><msup><mn>10</mn><mn>5</mn></msup></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><msub><mi>P</mi><mi>i</mi></msub><mo></mo><msup><mn>10</mn><mn>3</mn></msup></math></p><p><strong>Sample Input</strong></p><p>1
</p><p>4 4
</p><p>17 4
</p><p>20 2
</p><p>10 7
</p><p>15 5
</p><p><strong>Sample Output</strong></p><p>37
</p><p><strong>Explanation</strong></p><p>Here, Shengij will perform the magic spell on apple number&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math>&nbsp;and he will buy&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>1</mn><mrow class="MJX-TeXAtom-ORD"><mi>s</mi><mi>t</mi></mrow></msup></math>&nbsp;and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mi>d</mi></mrow></msup></math>&nbsp;apples to maximize the total vitamin.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int i,n, m, sum, a[1002][2];
void sol()
{
    cin >> n >> m;
    for(int i = 1; i <= m; i ++)a[i][0] = a[i][1] = -1;
    a[0][0] = 0;
    a[0][1] = -1;
    sum = 0;
    for(i=1;i<=n;i++)
    {
        int v, p;
        cin >> v >> p;
        for(int j = min(m-p/2, sum); j >= 0; j --)
        {
            if(a[j][1] != -1 && j + p <= m)a[j+p][1] = max(a[j+p][1], a[j][1] + v);
            if(a[j][0] != -1)
            {
                if(j + p <= m)a[j+p][0] = max(a[j+p][0], a[j][0] + v);
                a[j+p/2][1] = max(a[j+p/2][1], a[j][0] + v);
            }
        }
        sum = min(m, sum + p);
    }
    int ans =0 ;
    for(int i = 1; i <= m; i ++)ans = max(ans, max(a[i][0], a[i][1]));
    cout << ans << '\n';
}
int main()
{
    int ntest = 1;
    cin >> ntest;
    while(ntest -- > 0)sol();
}

question

 <p><strong>Question description</strong></p><p>Samy has bought a box of chocolate and has brought them to Anand house. There is a random number on each chocolate. They decided to play a game with them.<br>They arranged them randomly in a row. They each start from one end of the row (Samy starts from left and Anand from right). They can only move towards each other, and in each step, they can move at most k chocolate.<br>More specifically Samy can go from the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msub></math>&nbsp;place to one of&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mtext>&nbsp;</mtext><mi>i</mi><mo>+</mo><mn>2</mn><mo>,</mo><mtext>&nbsp;</mtext><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mtext>&nbsp;</mtext><mi>i</mi><mo>+</mo><mi>k</mi></math>&nbsp;and Anand can go from&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msub></math>&nbsp;place to&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi><mo></mo><mn>1</mn><mo>,</mo><mtext>&nbsp;</mtext><mi>i</mi><mo></mo><mn>2</mn><mo>,</mo><mtext>&nbsp;</mtext><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mtext>&nbsp;</mtext><mi>i</mi><mo></mo><mi>k</mi></math>.<br>They can only eat the chocolate they are on if their number is the same. The game ends if they can&nbsp;eat any chocolate. Their goal is to&nbsp;eat the last chocolate together.</p><p>Determine if Samy and Anand can eat the last chocolate together (that is, they both finish in the same place).</p><p><strong>Note </strong>that in the initial state, they are on the first and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msub></math>&nbsp;place&nbsp;but they did not eat chocolates yet. So, if the number of the first and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msub></math>&nbsp;place chocolate differs, the game ends and they would not&nbsp;reach each other.&nbsp;Also, at each moment, they both have to move simultaneously, that is, one cannot stay at a place while another one is moving&nbsp;because if one stays at the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msub></math>&nbsp;place, there is not any chocolate to eat anymore.</p><p><strong>Input Format</strong></p><ul><li>The first line of input contains integers&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math>&nbsp;and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math>&nbsp;denoting&nbsp;the length of the array&nbsp;and the maximum length of their steps respectively.</li><li>The second line contains&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math>&nbsp;integers denoting&nbsp;the elements of array&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>.</li></ul><p><strong>Output format</strong></p><p>Print "YES" if they can eat the last chocolate together and "NO" if they cannot.<br><strong>Note</strong>: The letters in the words "YES" and "NO" should be uppercase.</p><p><strong>Constraints</strong></p><p>1 n  1000</p><p>1 k  5<br>1 Ai 10</p><p><strong>Sample Input</strong></p><p>10 2
</p><p>1 2 1 3 3 7 4 3 2 1</p><p><strong>Sample Output</strong></p><p>YES</p><p><strong>Explanation</strong></p><p>Samy's path would be:&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msub><mo>,</mo><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>4</mn></mrow></msub><mo>,</mo><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>6</mn></mrow></msub></math><br>Anand path would be:&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>10</mn></mrow></msub><mo>,</mo><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>9</mn></mrow></msub><mo>,</mo><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>8</mn></mrow></msub><mo>,</mo><msub><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>6</mn></mrow></msub></math></p> 
answer

 #include<stdio.h>
int function(int arr[],int i,int j,int memo[][1001],int k)
{
	if(i>j)
	   return 0;
	if(arr[i]!=arr[j])
	   return 0;
	if(i==j)
	   return 1;
	if(memo[i][j]!=-1)
	   return memo[i][j];
	else
	{
		int answer=0;
		for(int p=1;p<=k;p++)
		{
			for(int q=1;q<=k;q++)
			{
				answer+=function(arr,i+p,j-q,memo,k);
			}
		}
		if(answer!=0)
		  answer=1;
		memo[i][j]=answer;
		return answer;
	}
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	int j,arr[n+1];
	for(j=1;j<=n;j++)
	   scanf("%d",&arr[j]);
   int memo[1001][1001];
//	int answer=0;
	int i;
	for(i=0;i<=1000;i++)
	{
		for(j=0;j<=1000;j++)
		{
			memo[i][j]=-1;
		}
	}
    int answer=function(arr,1,n,memo,k);
	if(answer==0)
	   printf("NO\n");
	else  
	   printf("YES\n");
}

question

 <p><strong>Question description</strong></p><p>You have infinite cards for each number between&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math>&nbsp;and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;(inclusive of them). Your task is to select three integers such that after sorting them in ascending order, the difference between the adjacent number is less than or equal to two. Find the number of ways to choose three numbers and print them.</p><p><strong>Note:</strong> The order of numbers does not matter.</p><p><strong>Constraints</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>T</mi><mo></mo><mn>20000</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo></mo><mn>200000</mn></math></p><p><strong>Input format</strong></p><ul><li>The first line contains an integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math>&nbsp;denoting the number of test cases.</li><li>For each test case, the first and only line contains an integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>.</li></ul><p><strong>Output format</strong></p><p>Print&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math>&nbsp;lines, one for each test case, denoting the number of ways.</p><p><strong>Sample Input</strong></p><p>2
</p><p>1
</p><p>3</p><p><strong>Sample Output</strong></p><p><strong>1</strong></p><p><strong>10</strong></p><p>&nbsp;</p><p><strong>Explanation</strong></p><p>For N=1 there is only one way:</p><ol><li>(1,1,1)</li></ol><p>For&nbsp;&nbsp;N=3</p><ol><li>(1,1,1)</li><li>(2,2,2)</li><li>(3,3,3)</li><li>(1,2,3)</li><li>(1,1,3)</li><li>(1,1,2)</li><li>(1,2,2)</li><li>(2,2,3)</li><li>(1,3,3)</li><li>(2,3,3)</li></ol><p>&nbsp;&nbsp; &nbsp;These are the 10 possible ways.</p> 
answer

 #include <bits/stdc++.h>
using namespace std;
using ll = long long int;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	//preSum();
	ll t;
	cin>>t;
	while(t--){
		ll n;
		cin>>n;
		if(n==1)
			printf("1\n");
		else if(n==2)
			printf("4\n");
		else if(n==3)
			printf("10\n");
		else
			printf("%lld\n",9*n-18);
	}
}

question

 <p><strong>Question description</strong></p><p>There are&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;sprinklers in a&nbsp;field. Each sprinkler has some range up to where it can sprinkle water.<br>All the sprinklers are on the X-axis at coordinates&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>X</mi><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>,</mo><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mi>X</mi><mn>2</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>,</mo><mtext>&nbsp;</mtext><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mo stretchy="false">(</mo><mi>X</mi><mi>N</mi><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></math>&nbsp;and their respective&nbsp;ranges are&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mn>1</mn><mo>,</mo><mtext>&nbsp;</mtext><mi>R</mi><mn>2</mn><mo>,</mo><mtext>&nbsp;</mtext><mi>R</mi><mn>3</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>R</mi><mi>N</mi></math>&nbsp;meaning that the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;sprinkler can sprinkle water from&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mi>X</mi><mi>i</mi><mo></mo><mi>R</mi><mi>i</mi><mo>,</mo><mtext>&nbsp;</mtext><mi>X</mi><mi>i</mi><mo>+</mo><mi>R</mi><mi>i</mi><mo stretchy="false">]</mo></math>&nbsp;inclusive.<br>There is a big wall at <strong>0</strong> meaning that the water can not go another side irrespective of range.</p><p>You are asked&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math>&nbsp;queries and&nbsp;in the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;query, you will be given an integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math>. Your task is to determine how many sprinklers are sprinkling the water at&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>K</mi><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></math>.<br>Assume, there is no sprinkler at&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></math>&nbsp;and there is no query that has&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>=</mo><mn>0</mn></math>.</p><p><strong>Constraints</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>T</mi><mo></mo><mn>10000</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo></mo><mn>100000</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>Q</mi><mo></mo><mi>N</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><msub><mi>X</mi><mi>i</mi></msub><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mo></mo><mi>N</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo></mo><msub><mi>R</mi><mi>i</mi></msub><mo></mo><mi>N</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mo></mo><mn>2</mn><mi>N</mi><mo></mo><mi>K</mi><mo></mo><mn>2</mn><mi>N</mi></math></p><p>The sum of&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;over all test cases do&nbsp;not exceed <strong>100000</strong>.</p><p>&nbsp;</p><p><strong>Input format</strong></p><ul><li>The first line contains an integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math>&nbsp;denoting the number of test cases.</li><li>The first line of each test case contains two integers&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math>&nbsp;denoting the number of sprinklers and number of queries.</li><li>The second line of each test case contains&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;space-separated integers denoting the X-coordinates of the sprinklers.</li><li>The third line of each test case contains&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;space-separated integers denoting the range of the sprinklers.</li><li>Next&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math>&nbsp;line of each test case&nbsp;contains&nbsp;an integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math>&nbsp;for the query.</li></ul><p><strong>Output format</strong></p><p>For each test case, print&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math>&nbsp;lines denoting the number of sprinklers that sprinkle water at the position in the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;query.</p><p><strong>Explanation:</strong></p><p><strong>Sample Input</strong></p><p>1
</p><p>5 5
</p><p>-2 -1 -3 1 2
</p><p>5 5 5 5 5
</p><p>-3
</p><p>-2
</p><p>-6
</p><p>5
</p><p>10</p><p><strong>Sample Output</strong></p><p>3
</p><p>3
</p><p>3
</p><p>2
</p><p>0</p><p><strong>Explanation</strong></p><p>There are 3 sprinklers which sprinkle water at -3 which are at (-2,-1,-3). Note that sprinker at co-ordinate x=1 has range upto -4 but there is a big wall at x=0.<br>Similar is the case with -2 and -6.<br>There are two sprinklers at (1,2) which can sprinkle water at 5.</p> 
answer

 #include <stdio.h>
int min(int a,int b){
	if (a<b){
		return(a);
	}
	else{
		return(b);
	}
}
int max(int a,int b){
	if (a>b){
		return(a);
	}
	else{
		return(b);
	}
}
int main(){
	int t;
	scanf("%d",&t);
	for(int i=0;i<t;i++){
		int n,q,k;
		scanf("%d %d",&n,&q);
		int a[n],b[n];
		for(int j=0;j<n;j++){
			scanf("%d",&a[j]);
		}
		for(int m=0;m<n;m++){
            scanf("%d",&b[m]);
		}
		int x=(4*n)+1;
		int sum[x];
		for (int m=0;m<x;m++){
			sum[m]=0;
		}
		for (int m=0;m<n;m++)
		{
			int low=a[m]-b[m];
			int up=a[m]+b[m]+1;
			if (a[m]>0){
				low=max(1,low);
			}
			if (a[m]<0){
				up=min(0,up);
			}
			low +=2*n;
			up +=2*n;
			sum[low]+=1;
			sum[up]-=1;
		}
		for (int y=1;y< 4*n+1;y++){
			sum[y]+=sum[y-1];
		}
		for(int m=0;m<q;m++){
			scanf("%d",&k);
			printf("%d\n",sum[k+(2*n)]);
		}
	}
}

question

 <p><strong>Problem Statement</strong></p><p>You are given two numbers <strong>n</strong> and <strong>k</strong>. For each number in the interval <strong>[1, n]</strong>, your task is to calculate its largest divisor&nbsp;that is not divisible by <strong>k</strong>. Print the sum of these divisors.</p><p>Note: <strong>k</strong> is a prime number.</p><p><strong>Input format</strong></p><ul><li>The first line contains an integer T representing the number of test cases that will follow.</li><li>Each test case consists of one line containing two integers n and k.</li></ul><p><strong>Output format</strong></p><p>The output must contain the answer for each test case on a different line.</p><p>Each answer consists of a single integer.</p><p><strong>Constraints</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mo></mo><mn>300000</mn><mspace linebreak="newline">&nbsp;</mspace><mn>1</mn><mo></mo><mi>n</mi><mo></mo><mn>1000000000</mn><mspace linebreak="newline">&nbsp;</mspace><mn>2</mn><mo></mo><mi>k</mi><mo></mo><mn>1000000000</mn></math><br>&nbsp;</p><p><strong>Sample Input</strong></p><p>4
</p><p>10 3
</p><p>10 2
</p><p>10 5
</p><p>1000000000 97</p><p><strong>Sample Output</strong></p><p>41
</p><p>36
</p><p>43
</p><p>494897959532893312
</p><p><strong>Explanation</strong></p><p>In the first test case, f (x) from 1 to 10 is [1, 2, 1, 4, 5, 2, 7, 8, 1, 10], sum of which is 41.</p><p>In the second&nbsp;test case, f (x) from 1 to 10&nbsp;is [1, 1, 3, 1, 5, 3, 7, 1, 9, 5].</p><p>In the third&nbsp;test case, f (x) from 1 to 10 is [1, 2, 3, 4, 1, 6, 7, 8, 9, 2].</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
 
using ll = long long;
 
long long f(int n, int k) {
    if (n == 0) return 0;
    long long res = (n/k);
    return f(n/k, k) + n * (ll)(n+1) / 2ll - (res * (res + 1) / 2ll) * k;
}                   
 
int main () {
    int T = 1;
    scanf("%d", &T);
    assert(T >= 1 && T <= 300000);
    while(T--) {
 
        int n, k;
        scanf("%d%d", &n, &k);
        assert(n <= 1e9);
        assert(k >= 2 && k <= 1e9);
 
        printf("%lld\n", f(n, k));
        
    }
 
    return 0;
}

question

 <p><strong>Problem statement</strong></p><p>Samu is playing a shooting game in play station. There are two apples to aim in this shooting game. Hitting first apple will provide her <strong>X</strong> points and hitting second apple will provide her <strong>Y</strong> points. And if she misses the apple she chose to hit, she wont get any point.<br>&nbsp;</p><p>Now she is having <strong>N</strong> coins and each shoot will cost her <strong>1</strong> coin and she needs to score at least <strong>W</strong> points to win the game.</p><p>Samu don't like to loose at any cost. At each turn, she has two choices. The choices include:-<br>&nbsp;</p><ul><li>Hitting first apple with probability <strong>P1</strong> percent. However, she might miss it with probability <strong>(1-P1)</strong> percentage.</li><li>Hitting second apple with probability <strong>P2</strong> percent. However, she might miss it with probability <strong>(1-P2)</strong> percentage.</li></ul><p>She would like to know what is the maximal expected probability(as a percentage b/w 0 and 100) of winning the shooting game.</p><p><strong>Input Format:</strong><br>First line contains the number of test cases <strong>T</strong>.<br>Each test case consists of six space separated integers of the form <strong>X Y N W P1 P2</strong> as described in the statement.</p><p><strong>Output Format:</strong><br>For each test case, print the result as described above in a separate line.</p><p><strong>Note:</strong><br>Choosing to hit any apple is entirely her choice. Both are independent events meaning <strong>P1</strong> + <strong>P2</strong> may/may not exceed 100.<br>Output must contain 6 digits after decimal.<br>&nbsp;</p><p><strong>Constraints:</strong><br><strong>1  T  10</strong><br><strong>1  X,Y  10</strong><br><strong>1  N,W  10<sup>3</sup></strong><br><strong>0  P1,P2  100</strong></p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define MAXN 1010
#define MAXW 1010
double DP[MAXN][MAXW];
int main(){
	int t;
	cin>>t;
	while(t--){
		int X,Y,N,W,P1,P2;
		cin>>X>>Y>>N>>W>>P1>>P2;
		for(int i=0;i<=N;i++){
			for(int j=0;j<=W;j++){
				DP[i][j]=0;
			}
		}
		double p1 = 0.01 * P1;
		double p2 = 0.01 * P2;
		for (int i=0;i<=N;i++) 
      		DP[i][0] = 1; 
    	for (int i=1;i<=W;i++) 
      		DP[0][i] = 0; 
    	for (int i=1;i<=N;i++){ 
      		for (int j=1;j<=W;j++) { 
        		DP[i][j] = max(p1*DP[i-1][max(j-X,0)] + (1-p1)*DP[i-1][max(j,0)], p2*DP[i-1][max(j-Y,0)] + (1-p2)*DP[i-1][max(j,0)]); 
      		} 
      	}
      	printf("%.6f\n",DP[N][W]*100);
 
	}
}

question

 <p><strong>Problem Statement</strong></p><p>You are given three arrays&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn><mo></mo><mi>n</mi></mrow></msub><mo>,</mo><msub><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn><mo></mo><mi>n</mi></mrow></msub><mo>,</mo><msub><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn><mo></mo><mi>n</mi></mrow></msub></math>&nbsp;and two numbers <i><strong>M</strong></i>&nbsp;and <i><strong>K</strong></i>. Find a lexicographically minimum&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo fence="false" stretchy="false">}</mo></math>&nbsp;such that there are exactly <i><strong>K</strong></i>&nbsp;indices&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo></mo><mi>i</mi><mo></mo><mi>n</mi><mo stretchy="false">)</mo></math>&nbsp;where&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo></mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>y</mi><mo></mo><msub><mi>b</mi><mi>i</mi></msub><mo></mo><msub><mi>c</mi><mi>i</mi></msub><mo></mo><mi>z</mi><mo>=</mo><mi>M</mi><mo></mo><mi>f</mi></math>&nbsp;for some integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi></math>. Also, you are given ranges of&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math>,&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math>, and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>z</mi></math>--&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>l</mi><mrow class="MJX-TeXAtom-ORD"><mn>1..3</mn></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mn>1..3</mn></mrow></msub></math>(<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>l</mi><mn>1</mn></msub><mo></mo><mi>x</mi><mo></mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>l</mi><mn>2</mn></msub><mo></mo><mi>y</mi><mo></mo><msub><mi>r</mi><mn>2</mn></msub><mo>,</mo><msub><mi>l</mi><mn>3</mn></msub><mo></mo><mi>z</mi><mo></mo><msub><mi>r</mi><mn>3</mn></msub><mo stretchy="false">)</mo></math>.&nbsp;Here, a triplet of integers&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>z</mi><mn>1</mn></msub><mo fence="false" stretchy="false">}</mo></math>&nbsp;is considered to be lexicographically smaller than a triplet&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>,</mo><msub><mi>z</mi><mn>2</mn></msub><mo fence="false" stretchy="false">}</mo></math>&nbsp;if sequence&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>z</mi><mn>1</mn></msub><mo stretchy="false">]</mo></math>&nbsp;is lexicographically smaller than sequence&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>,</mo><msub><mi>z</mi><mn>2</mn></msub><mo stretchy="false">]</mo></math>. A sequence <i><strong>a</strong></i>&nbsp;is lexicographically smaller than a sequence <i><strong>b</strong></i>&nbsp;if in the first position where <i>a</i>&nbsp;and <i>b</i> differ, the sequence&nbsp;<i><strong>a</strong></i> has a smaller element than the corresponding element in <i><strong>b</strong></i>.</p><p><strong>Input format</strong></p><ul><li>The first line contains one three integers&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>,</mo><mi>m</mi><mo>,</mo><mi>K</mi><mo stretchy="false">(</mo><mn>1</mn><mo></mo><mi>n</mi><mo></mo><mn>10000</mn><mo>,</mo><mn>0</mn><mo></mo><mi>K</mi><mo></mo><mi>n</mi><mo>,</mo><mn>1</mn><mo></mo><mi>M</mi><mo></mo><mn>15</mn><mo stretchy="false">)</mo></math>.</li><li>The next&nbsp;<strong>n</strong> lines contain three integers&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mi>i</mi></msub><mo>,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo></mo><msub><mi>a</mi><mi>i</mi></msub><mo>,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>c</mi><mi>i</mi></msub><mo></mo><msup><mn>10</mn><mn>9</mn></msup><mo stretchy="false">)</mo></math>.</li><li>The next three lines contain two integers&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>l</mi><mi>i</mi></msub><mo>,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo></mo><msub><mi>l</mi><mi>i</mi></msub><mo></mo><msub><mi>r</mi><mi>i</mi></msub><mo></mo><msup><mn>10</mn><mn>9</mn></msup><mo stretchy="false">)</mo></math>.</li></ul><p><strong>Output format</strong></p><p>If an answer does not exist, print <strong>-1</strong>. Otherwise,&nbsp;print desirable&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo fence="false" stretchy="false">}</mo></math>.</p><p><strong>Sample Input</strong></p><p>4 3 4
</p><p>5 6 1
</p><p>2 6 9
</p><p>11 5 6
</p><p>1 1 1
</p><p>1 10
</p><p>1 10
</p><p>1 10
</p><p><strong>Sample Output</strong></p><p>3 3 3
</p><p><strong>Explanation</strong></p><p>Since,&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>=</mo><mi>n</mi><mo>=</mo><mn>4</mn></math>, the above condition must hold for all indices</p><p>.&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="1em">&nbsp;</mspace><mn>3</mn><mo></mo><mn>5</mn><mo>+</mo><mn>3</mn><mo></mo><mn>6</mn><mo></mo><mn>3</mn><mo></mo><mn>1</mn><mo>=</mo><mn>30</mn><mspace linebreak="newline">&nbsp;</mspace><mi>i</mi><mo>=</mo><mn>2</mn><mo stretchy="false">)</mo><mspace width="1em">&nbsp;</mspace><mn>3</mn><mo></mo><mn>2</mn><mo>+</mo><mn>3</mn><mo></mo><mn>6</mn><mo></mo><mn>3</mn><mo></mo><mn>9</mn><mo>=</mo><mo></mo><mn>3</mn><mspace linebreak="newline">&nbsp;</mspace><mi>i</mi><mo>=</mo><mn>3</mn><mo stretchy="false">)</mo><mspace width="1em">&nbsp;</mspace><mn>3</mn><mo></mo><mn>11</mn><mo>+</mo><mn>3</mn><mo></mo><mn>5</mn><mo></mo><mn>3</mn><mo></mo><mn>6</mn><mo>=</mo><mn>30</mn><mspace linebreak="newline">&nbsp;</mspace><mi>i</mi><mo>=</mo><mn>4</mn><mo stretchy="false">)</mo><mspace width="1em">&nbsp;</mspace><mn>3</mn><mo></mo><mn>1</mn><mo>+</mo><mn>3</mn><mo></mo><mn>1</mn><mo></mo><mn>3</mn><mo></mo><mn>1</mn><mo>=</mo><mn>3</mn></math>.</p> 
answer

 #include <iostream>
#include<bits/stdc++.h>
#define f1 for(i=0;i<n;i++)
using namespace std;
long long int min(long long int x, long long int y){
	if(x < y)
	    return x;
	else
	    return y;
}
int main(){
	int n, m, K;
	cin >> n >> m >> K;
	long long int a[n],b[n],c[n];
	long long int i,j,l;
	int p,T = 0;
	for(i = 0; i < n; i++)
	cin >> a[i] >> b[i] >> c[i];
	long long int lx,rx,ly,ry,lz,rz;
	cin >> lx >> rx;
	cin >> ly >> ry;
	cin >> lz >> rz;
	for(i = lx; i < min(rx, lx + m); i++){
		for(j = ly; j < min(ry,ly + m);j++){
			for(l = lz;l < min(rz,lz + m);l++){
				T=0;
				for(p = 0; p < n; p++){
					if((a[p] * i + b[p] * j- c[p] * l) % m == 0)
					T++;
				}
				if(T==K)
				break;
			}
			if(l < min(rz,lz + m))
			break;
		}
		if(j < min(ry,ly + m))
		break;
 
	}
	if(i < min(rx, lx + m)){
		cout << i << " " << j << " " << l;
	}
	else
	cout << "-1" << endl;
}

question

 <p>During the break the schoolchildren, boys and girls, formed a queue of <i>n</i> people in the canteen. Initially the children stood in the order they entered the canteen. However, after a while the boys started feeling awkward for standing in front of the girls in the queue and they started letting the girls move forward each second.</p><p>Let's describe the process more precisely. Let's say that the positions in the queue are sequentially numbered by integers from 1 to <i>n</i>, at that the person in the position number 1 is served first. Then, if at time <i>x</i> a boy stands on the <i>i</i>-th position and a girl stands on the (<i>i</i>+1)-th position, then at time <i>x</i>+1 the <i>i</i>-th position will have a girl and the (<i>i</i>+1)-th position will have a boy. The time is given in seconds.</p><p>You've got the initial position of the children, at the initial moment of time. Determine the way the queue is going to look after <i>t</i> seconds.</p><p><strong>Input</strong></p><p>The first line contains two integers <i>n</i> and <i>t</i> (1<i>n</i>,<i>t</i>50), which represent the number of children in the queue and the time after which the queue will transform into the arrangement you need to find.</p><p>The next line contains string <i>s</i>, which represents the schoolchildren's initial arrangement. If the <i>i</i>-th position in the queue contains a boy, then the <i>i</i>-th character of string <i>s</i> equals "B", otherwise the <i>i</i>-th character equals "G".</p><p><strong>Output</strong></p><p>Print string <i>a</i>, which describes the arrangement after <i>t</i> seconds. If the <i>i</i>-th position has a boy after the needed time, then the <i>i</i>-th character <i>a</i> must equal "B", otherwise it must equal "G".</p> 
answer

 #include<iostream>
int main(){
    int n,t; 
    std::cin>>n>>t;
    std::string s;
    std::cin>>s;
    for(int i=0;i<t;i++) 
    {for(int j=0;j<n;j++)
    if(s[j]=='B'&&s[j+1]=='G')
    {std::swap(s[j],s[j+1]);j++;}}
    std::cout<<s;
    return 0;
   std::cout<<"int i,k,n; while(k){ char a[n+3];";
    
}

question

 <p><strong>Problem statement</strong></p><p>Lucky numbers are defined as the numbers consisting only of digits <strong>3</strong> and <strong>5</strong>. So, given a number N, you have to print the least lucky number strictly greater than <strong>N</strong>.</p><p><strong>Input:</strong><br>First line of input contains number of test cases <strong>T</strong>. Each test case contains a single number <strong>N</strong>.</p><p><strong>Output:</strong><br>For each test case, print the next lucky number in a separate line.</p><p><strong>Constraints:</strong><br>1&lt;=<strong>T</strong>&lt;=1000<br>1&lt;=<strong>N</strong>&lt;=10<sup>100</sup></p> 
answer

 #include<bits/stdc++.h>
using namespace std;
 
string solve(string& s)
{
    int n = s.size(), i = 0;
    while(i < n && (s[i] == '3' || s[i] == '5'))
    ++i;
    if(i < n && (s[i] < '5'))
    {
        if(s[i] == '4')
            s[i] = '5';
        else
            s[i]='3';
        ++i;
        while(i<n)
        {
            s[i] = '3';
            ++i;
        }
    }
    else
    {
        while(i >= 0 && (s[i] != '3'))
        	--i;
        if(i < 0)
            return string(n + 1, '3');
        s[i] = '5';
        ++i;
        while(i < n)
        {
            s[i] = '3';
            ++i;
        }
    }
    return s;
}
 
int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    int t; 
	cin >> t; 
	while(t--)
    {
    	string s;
    	cin >> s;
    	cout << solve(s) << endl;
    }
}

question

 <p>Question Description:</p><p>Teja has given a permutation of numbers from 1 to <i>n</i>.&nbsp;</p><p>Determine whether there's a pair of integers <i>a</i>,<i>b</i> (1<i>a</i>,<i>b</i><i>n</i>;&nbsp;<i>a</i><i>b</i>) such that the element (note, that it is usual division, not integer one) is between <i>a </i>and <i>b </i>in this permutation.</p><p>Constraints:</p><p>1<i>n</i>300000</p><p>Input Format:</p><p>First line consists of a single integer <i>n</i> the size of permutation.</p><p>Second line contains <i>n</i> integers the permutation itself.</p><p>Output Format:</p><p>Print "YES", if such a pair exists, "NO" otherwise (in both cases without quotes, the answer is case insensitive).</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int a[300010],n,p[300010];
void update(int t,int l,int r,int x){
    cout<<"int query(int t,int l,int r,int L,int R)cin>>x;";
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	    scanf("%d",&a[i]);
	    p[a[i]]=i;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=min(n,i+5);j++)
		{
			if(a[i]*2-a[j]>0&&a[i]*2-a[j]<=n&&p[a[i]*2-a[j]]<i)
			    return puts("YES"),0;
			if(a[j]*2-a[i]>0&&a[j]*2-a[i]<=n&&p[a[j]*2-a[i]]>j)
			    return puts("YES"),0;
		}
	}
	puts("NO");
	return 0;
}

question

 <p style="text-align:justify;">Question Description:</p><p style="text-align:justify;">Fazil is an unemployed computer scientist who spends his days working at odd-jobs. While on the job he always manages to find algorithmic problems within mundane aspects of everyday life.</p><p style="text-align:justify;">Today, while writing down the specials menu at the restaurant he's working at, he felt irritated by the lack of palindromes (strings which stay the same when reversed) on the menu.&nbsp;</p><p style="text-align:justify;">Fazil is a big fan of palindromic problems, and started thinking about the number of ways he could remove letters from a particular word so that it would become a palindrome.</p><p style="text-align:justify;">Two ways that differ due to order of removing letters are considered the same. And it can also be the case that no letters have to be removed to form a palindrome.</p><p style="text-align:justify;">Constraints:</p><p style="text-align:justify;">1  length(W)  60</p><p style="text-align:justify;">Input Format:</p><p style="text-align:justify;">Input starts with an integer each case contains a single word W.</p><p style="text-align:justify;">Output Format:</p><p style="text-align:justify;">For each case, print the case number and the total number of ways to remove letters from W such that it becomes a palindrome.</p> 
answer

 #include <bits/stdc++.h>
using namespace std;
#define ll long long
const int inf = 1e9;
const int N = 62;
char word[N];
ll dp[N][N];
long long calculate(int s,int e) {
    if (s > e) return 0;
    if (s ==e) return 1;
    ll &p = dp[s][e];
    if (p != -1) return p;
    p = 0;
    if (word[s] == word[e]) p = 1 + calculate(s+1, e-1);
    p += (calculate (s+1, e) + calculate (s, e-1) - calculate (s+1, e-1));
    return p;
}
int main ()
{
    ll res;
        cin>>word;
        memset (dp, -1, sizeof (dp));
        res = calculate (0, strlen(word)-1);
        printf ("%lld\n", res);

    return 0;
}

question

 <p>Question Description:</p><p style="text-align:justify;">Maakesh caught the trail of the ancient Book of Evil in a swampy area. This area contains <i>n</i> settlements numbered from 1 to <i>n</i>. Moving through the swamp is very difficult, so people tramped exactly <i>n</i>-1 paths. Each of these paths connects some pair of settlements and is bidirectional. Moreover, it is possible to reach any settlement from any other one by traversing one or several paths.</p><p style="text-align:justify;">The <i>distance</i> between two settlements is the minimum number of paths that have to be crossed to get from one settlement to the other one. Maakesh knows that the Book of Evil has got a damage range <i>d</i>. This means that if the Book of Evil is located in some settlement, its damage (for example, emergence of ghosts and werewolves) affects other settlements at distance <i>d</i> or less from the settlement where the Book resides.</p><p style="text-align:justify;">Maakesh has heard of <i>m</i> settlements affected by the Book of Evil. Their numbers are <i>p</i><sub>1</sub>,<i>p</i><sub>2</sub>,...,<i>p<sub>m</sub></i>. Note that the Book may be affecting other settlements as well, but this has not been detected yet. Maakesh wants to determine which settlements may contain the Book. Help him with this difficult task.</p><p>Constraints:</p><p>1<i>m</i><i>n</i>100000</p><p>0<i>d</i><i>n</i>-1</p><p>1<i>p<sub>i</sub></i><i>n</i></p><p>Input Format:</p><p>The first line contains three space-separated integers <i>n</i>, <i>m</i> and <i>d</i>.&nbsp;</p><p>The second line contains <i>m</i> distinct space-separated integers <i>p</i><sub>1</sub>,<i>p</i><sub>2</sub>,...,<i>p<sub>m</sub></i>.&nbsp;</p><p>Then <i>n</i>-1 lines follow, each line describes a path made in the area. A path is described by a pair of space-separated integers <i>a<sub>i</sub></i> and <i>b<sub>i</sub></i> representing the ends of this path.</p><p>Output Format:</p><p>Print a single number the number of settlements that may contain the Book of Evil.&nbsp;</p><p>It is possible that Maakesh received some controversial information and there is no settlement that may contain the Book. In such case, print 0.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define f(n) for(int i=1;i<=n;i++)
#define g(n) for(int i=1;i<n;i++)
const int N=100005;
vector<int>e[N];
int can[N],d1[N],d2[N],d3[N],n,m,d,p1,p2,ans;
void dfs(int u,int f,int* d){
	d[u]=d[f]+1;
	for(int i=0;i<(int)e[u].size();i++)
		if(e[u][i]!=f)
			dfs(e[u][i],u,d); 
}
int main(){
	cin>>n>>m>>d;
	f(m) {
		int p;
		scanf("%d",&p);
		can[p]=1;
	}
	g(n) {
		int a,b;
		scanf("%d%d",&a,&b);
		e[a].push_back(b);
		e[b].push_back(a);
	}
	dfs(1,0,d1);
	f(n)
		if(can[i]&&d1[i]>d1[p1])
			p1=i;
	dfs(p1,0,d2);
	f(n)
		if(can[i]&&d2[i]>d2[p2])
			p2=i;
	dfs(p2,0,d3);
	f(n)
		if(d2[i]<=d+1&&d3[i]<=d+1)
			ans++;
	printf("%d\n",ans);
	return 0;
	cout<<"void evil(int u,int p=0)";
}

question

 <p>Question Description:</p><p>A long time ago, in a galaxy far far away two giant IT-corporations Avocado and Bobol continue their fierce competition. Crucial moment is just around the corner: Bobol is ready to release it's new tablet Lastus 3000.</p><p>This new device is equipped with specially designed artificial intelligence (AI). Employees of Avocado did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Avocado released 200 years ago.&nbsp;</p><p>As all rights on its name belong to Avocado, they stand on changing the name of Bobol's artificial intelligence.</p><p>Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Bobol's director decided to replace some characters in AI name with "#". As this operation is pretty expensive, you should find the minimum number of characters to replace with "#", such that the name of AI doesn't contain the name of the phone as a substring.</p><p>Substring is a continuous subsequence of a string.</p><p>Constraints:</p><p>1<i>n</i>100</p><p>Input Format:</p><p>The first line of the input contains the name of AI designed by Bobol, its length doesn't exceed 100000 characters.&nbsp;</p><p>Second line contains the name of the phone released by Avocado 200 years ago, its length doesn't exceed 30.&nbsp;</p><p>Both string are non-empty and consist of only small English letters.</p><p>Output Format:</p><p>Print the minimum number of characters that must be replaced with "#" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.</p> 
answer

 #include<bits/stdc++.h>

int a,i;
int main()
{std::string s,t;
std::cin>>s>>t;
for(i=s.find(t);i+1;++a,i=s.find(t,i+t.size()));std::cout<<a;}

question

 <p>Question Description:</p><p style="text-align:justify;">There are <i>n</i> banks in the city where Vishnu lives, they are located in a circle, such that any two banks are neighbouring if their indices differ by no more than 1. Also, bank 1 and bank <i>n</i> are neighbours if <i>n</i>&gt;1. No bank is a neighbour of itself.</p><p style="text-align:justify;">Vishnu has an account in each bank. Its balance may be negative, meaning Vishnu owes some money to this bank.</p><p style="text-align:justify;">There is only one type of operations available: transfer some amount of money from any bank to account in any neighbouring bank.&nbsp;</p><p style="text-align:justify;">There are no restrictions on the size of the sum being transferred or balance requirements to perform this operation.</p><p style="text-align:justify;">Vishnu doesn't like to deal with large numbers, so he asks you to determine the minimum number of operations required to</p><p style="text-align:justify;">change the balance of each bank account to zero.&nbsp;</p><p style="text-align:justify;">It's guaranteed, that this is possible to achieve, that is, the total balance of Vishnu in all banks is equal to zero.</p><p>Constraints:</p><p>1<i>n</i>100000</p><p>-10<sup>9</sup><i>a<sub>i</sub></i>10<sup>9</sup></p><p>Input Format:</p><p>The first line of the input contains a single integer <i>n</i> the number of banks.</p><p>The second line contains <i>n</i> integers <i>a<sub>i</sub></i>, the <i>i</i>-th of them is equal to the initial balance of the account in the <i>i</i>-th bank.&nbsp;</p><p>It's guaranteed that the sum of all <i>a<sub>i</sub></i> is equal to 0.</p><p>Output Format:</p><p>Print the minimum number of operations required to change balance in each bank to zero.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define maxs long long

map <maxs,maxs> a;
maxs i,n,k,x,p;
int main(){
    cin>>n;
    for(;i<n;i++)cin>>x,k+=x,a[k]++,p=max(p,a[k]);
    cout<<n-p;
}

question

 <p>Question Description:</p><p>It's a very unfortunate day for Lavanya today. He got bad mark in algebra and was therefore forced to do some work in the kitchen, namely to cook borscht (traditional Russian soup). This should also improve his algebra skills.</p><p>According to the borscht recipe it consists of <i>n</i> ingredients that have to be mixed in proportion&nbsp;</p><figure class="image"><img src="https://espresso.codeforces.com/4467b8f0f99d920b459ab653d9632f721329571b.png"></figure><p>litres (thus, there should be <i>a</i><sub>1</sub><i>x</i>,...,<i>a<sub>n</sub></i><i>x</i> litres of corresponding ingredients mixed for some non-negative <i>x</i>).&nbsp;</p><p>In the kitchen Lavanya found out that he has <i>b</i><sub>1</sub>,...,<i>b<sub>n</sub></i> litres of these ingredients at his disposal correspondingly.&nbsp;</p><p>In order to correct his algebra mistakes he ought to cook as much soup as possible in a <i>V</i> litres volume pan (which means the amount of soup cooked can be between 0 and <i>V</i> litres).&nbsp;</p><p>What is the volume of borscht Lavanya will cook ultimately?</p><p>Constraints:</p><p>1<i>n</i>20</p><p>1<i>V</i>10000</p><p>1<i>a<sub>i</sub></i>100</p><p>0<i>b<sub>i</sub></i>100</p><p>Input Format:</p><p>The first line of the input contains two space-separated integers <i>n</i> and <i>V</i>.&nbsp;</p><p>The next line contains <i>n</i> space-separated integers <i>a<sub>i</sub></i>. Finally, the last line contains <i>n</i> space-separated integers <i>b<sub>i</sub></i>.</p><p>Output Format:</p><p>Your program should output just one real number the volume of soup that Lavanya will cook. Your answer must have a relative or absolute error less than 10<sup>-4</sup>.</p> 
answer

 #include <bits/stdc++.h>
using namespace std;
#define res cin>>a[i],num+=a[i];
#define f1 	for(int i=1;i<=n;i++)
double n,v,a[25],b[25],sum,mx=1e9;
int main(){
	cin>>n>>v;
	f1{
		cin>>a[i];
		sum+=a[i];
	}
	for(int i=1;i<=n;i++)
		cin>>b[i];
	for(int i=1;i<=n;i++)
		mx=min(mx,b[i]/a[i]); 
	cout << fixed<<setprecision(1)<<min(mx*sum,v);
    return 0;
}

question

 <p>Question Description:</p><p>Programmer Sandhosh and you have a New Year Tree (not the traditional fur tree, though) a tree of four vertices: one vertex of degree three (has number 1), connected with three leaves (their numbers are from 2 to 4).</p><p>On the New Year, programmers usually have fun. You decided to have fun as well by adding vertices to the tree. One adding operation looks as follows:</p><ul><li>First we choose some leaf of the tree with number <i>v</i>.</li><li>Let's mark the number of vertices on the tree at this moment by variable <i>n</i>, then two vertexes are added to the tree, their numbers are <i>n</i>+1 and <i>n</i>+2, also you get new edges, one between vertices <i>v</i> and <i>n</i>+1 and one between vertices <i>v</i> and <i>n</i>+2.</li></ul><p>Your task is not just to model the process of adding vertices to the tree, but after each adding operation print the diameter of the current tree. Come on, let's solve the New Year problem!</p><p>Constraints:</p><p>1<i>q</i>510<sup>5</sup></p><p>1<i>v<sub>i</sub></i><i>n</i></p><p>Input Format:</p><p>The first line contains integer <i>q</i> the number of operations.&nbsp;</p><p>Each of the next <i>q</i> lines contains integer <i>v<sub>i</sub></i> the operation of adding leaves to vertex <i>v<sub>i</sub></i>.&nbsp;</p><p>Variable <i>n</i> represents the number of vertices in the current tree.</p><p>It is guaranteed that all given operations are correct.</p><p>Output Format:</p><p>Print <i>q</i> integers the diameter of the current tree after each operation.</p> 
answer

 #include <iostream>
int L[1000005],N=4,P[1000005][20],Q,v,i,p=2,q=3,d=2;
using namespace std;
int lca(int x,int y){
    cout<<"int dis(int x,int y) cin>>u;";
    return 1;
}
int f(int a, int b)
{
    if(L[a]<L[b])swap(a,b);
    for(i=0;i<20;i++)if((L[a]-L[b])&(1<<i))a=P[a][i];
    for(i=19;i>=0;i--)if(P[a][i]!=P[b][i])a=P[a][i],b=P[b][i];
    return P[a][0];
}
int main()
{
    L[2]=L[3]=L[4]=1,P[2][0]=P[3][0]=P[4][0]=1;
    cin>>Q;
    while(Q--)
    {
        cin>>v;
        L[N+1]=L[N+2]=L[v]+1,P[N+1][0]=P[N+2][0]=v,N+=2;
        for(i=1;i<20;i++)P[N][i]=P[P[N][i-1]][i-1],P[N-1][i]=P[P[N-1][i-1]][i-1];
        if(L[N]+L[p]-2*L[f(N,p)]>d)q=N,d++;
        if(L[N]+L[q]-2*L[f(N,q)]>d)p=N,d++;
        cout<<d<<"\n";
    }
}

question

 <p><strong>Problem Description:</strong></p><p>There are two types of vehicles in Chennai.</p><ul><li><strong>Lorry</strong> which has a capacity of 100 people.</li><li><strong>Auto</strong> which has a capacity of 4 people.</li></ul><p>There are N people who want to travel from place A to place B. You know that a single lorry release X units of sound while a single auto release Y units of sound in their journey from A to B.</p><p>Ragu want to arrange some lorries and autos to carry all these N people such that total sound released is minimized. Output the minimized sound value.</p><p><strong>Constraints:</strong></p><ul><li>1T1000</li><li>1N1000</li><li>1X,Y1000</li></ul><p><strong>Input Format:</strong></p><ul><li>First line will contain T, the number of test cases. Then the test cases follow.</li><li>Each test case contains three integers N, X, Y - the number of people who want to travel, the units of sound released by a lorry and the units of sound released by an auto respectively.</li></ul><p><strong>Output Format:</strong></p><p>Print the output the minimum units of sound released in transporting the N people.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
void for_(){}
int main()
{
    float t,n,ls,as;
    cin>>t;
    while(t--){
        cin>>n>>ls>>as;
        float x=as*ceil(n/4),y=ls*ceil(n/100);
        if(x<y) cout<<x<<endl;
        else if(n>100) cout<<ceil((n-100)/4)*as+ls<<endl;
        else cout<<y<<endl;
    }
    
}

question

 <p><strong>Problem Description:</strong></p><p>Palani goes to the Koyembedu Vegetables Market to buy some Vegetables. Luckily there's a sale going on under which Palani gets the following offer:</p><ul><li>If Palani buys 3 Vegetables then he gets the Vegetable (out of those 3 Vegetables) having the lowest price as free.</li></ul><p>For e.g. if Palani bought 3 Vegetables with the cost 6, 2 and 4, then he would get the Vegetable with cost 2 as free. So he would only have to pay the cost of the other two Vegetables which will be 6+4=10.</p><p>Palani buys 3 Vegetables having prices A, B and C respectively. What is the amount of money Palani needs to pay?</p><p><strong>Constraints:</strong></p><ul><li>1T100</li><li>1A,B,C10</li></ul><p><strong>Input Format:</strong></p><ul><li>The first line will contain an integer T - number of test cases. Then the test cases follow.</li><li>The first and only line of each test case contains three integers A,B,C - the prices of the Vegetables bought by Palani.</li></ul><p><strong>Output Format:</strong></p><p>Print the output the price paid by Palani.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define if hha
int main()
{
    int i,t;
    cin>>t;
    while(t--){
        int a[3];
        for(i=0;i<3;i++)
        cin>>a[i];
        sort(a,a+3);
        cout<<a[2]+a[1]<<endl;
    }
	return 0;
}

question

 <p><strong>Problem Description:</strong></p><p>Ajith Kumar wants to reach Lord Murugan Temple as soon as possible. He has two options:</p><ul><li>Travel with his <strong>Royal Enfield </strong>which takes X minutes.</li><li>Travel with his <strong>Audi</strong> which takes Y minutes.</li></ul><p>Which of the two options is faster or do they both take same time?</p><p><strong>Constraints:</strong></p><ul><li>1T100</li><li>1X,Y10</li></ul><p><strong>Input Format:</strong></p><ul><li>First line will contain T, number of test cases. Then the test cases follow.</li><li>Each test case contains a single line of input, two integers X,Y representing the time taken to travel with <strong>Royal Enfield</strong> and <strong>Audi</strong> respectively.</li></ul><p><strong>Output Format:</strong></p><p>Print <strong>Audi</strong> if travelling with <strong>Audi</strong> is faster, <strong>Royal Enfield</strong> if travelling with <strong>Royal Enfield</strong> is faster, <strong>SAME</strong> if they both take the same time.</p> 
answer

 #include<iostream>
using namespace std;
void for_(){

}
int main()
{
    int t;
    cin>>t;
    while(t--){
        int x,y;
        cin>>x>>y;
        if(x<y)
        cout<<"Royal Enfield"<<endl;
        else if(x==y) cout<<"SAME"<<endl;
        else cout<<"Audi"<<endl;
    }

    return 0;
}

question

 <p><strong>Question Description:</strong><br>Tesla recently found a new rectangular electric board that he would like to recycle. The electric board has A rows and B columns of squares.<br><br>Each square of the electric board has thinness, measured in millimeters. The square in the a-th row and b-th column has thinness Wa,b. An electric board is nice if in each row, the difference between the thinnest square and the least thin square is no greater than M.<br><br>Since the original electric board might not be nice, Tesla would like to find a nice subelectricboard. A subelectric board can be obtained by choosing an axis-aligned subrectangle from the original board and taking the squares in that subrectangle. Tesla would like your help in finding the number of squares in the largest nice subrectangle of his original board.<br><br><strong>Constraints:</strong><br>1  T  50.<br>1  A  200.<br>1  B  200.<br>0  Wi, j  10^3 for all i, j.<br><br><strong>Input Format:</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with one line containing three integers A, B and M, the number of rows, the number of columns, and the maximum difference in thinness allowed in each row.<br><br>Then, there are A more lines containing B integers each. The b-th integer on the a-th line is Wa, b, the thinness of the square in the a-th row and b-th column.<br><br><strong>Output Format:</strong><br>Print the output in a separate lines contains the maximum number of squares in a nice subrectangle.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
const int inf = 1012345678;
int A[309][309];
int H, W, K; bool ok[309][309][309];
int main() {
	int Q,rep;
	cin >> Q;
	for (rep = 1; rep <= Q; ++rep) {
		cin >> H >> W >> K;
		for (int i = 0; i < H; ++i) {
			for (int j = 0; j < W; ++j) {
				cin >> A[i][j];
			}
		}
		for (int i = 0; i < H; ++i) {
			for (int j = 0; j < W; ++j) {
				int cl = inf, cr = -inf;
				for (int k = j; k < W; ++k) {
					cl = min(cl, A[i][k]);
					cr = max(cr, A[i][k]);
					if (cr - cl <= K) {
						ok[i][j][k] = true;
					}
					else {
						ok[i][j][k] = false;
					}
				}
			}
		}
		int ans = 0;
		for (int i = 0; i < W; ++i) {
			for (int j = i; j < W; ++j) {
				int cont = 0;
				for (int k = 0; k < H; ++k) {
					if (ok[k][i][j]) ++cont;
					else cont = 0;
					ans = max(ans, cont * (j - i + 1));
				}
			}
		}
		cout << ans << endl;
	}
	return 0;
}

question

 <p>Problem Description:<br>Kadamban has planned a motorbike tour through the Western Ghats of Tamil Nadu. His tour consists of N checkpoints, numbered from 1 to N in the order he will visit them. The i-th checkpoint has a height of Hi.<br><br>A checkpoint is a peak if:<br><br>1. It is not the 1st checkpoint or the N-th checkpoint, and<br>2. The height of the checkpoint is strictly greater than the checkpoint immediately before it and the checkpoint immediately after it.<br><br>Please help Kadamban find out the number of peaks.<br><br>Constraints:<br>1  T  100.<br>1  Hi  100.<br>3  N  100.<br><br>Input Format:<br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Hi.<br><br>Output Format:<br>Print the output in a single line contains, the number of peaks in Kadamban's motorbike tour.</p> 
answer

 #include<iostream>
using namespace std;
int main()
{
int t,T;
cin>>T;
for(t=0;t<T;t++){
    int n,i,count=0;
    cin>>n;
    int a[n];
    for(i=0;i<n;i++){
        cin>>a[i];
    }
    for(i=1;i<n-1;i++){
        if((a[i]>a[i-1])&&(a[i]>a[i+1]))
        {
            count++;
        }
    }
    cout<<count<<endl;
    
}
    return 0;
}

question

 <p>Question Description:<br>Two terrorists called T1 and T2 are playing a competition with a starting number of Land mines. terrorist 1 always plays first, and the two terrorists move in alternating turns. The competition's rules are as follows:<br><br>1. In a single move, a terrorist can remove either 2, 3, or 5 Land mines from the competition board.<br>2. If a terrorist is unable to make a move, that terrorist loses the competition.<br><br>Given the starting number of Land mines, find and print the name of the winner.T1 is named First and T2 is named Second.&nbsp;<br><br>Each terrorist plays optimally, meaning they will not make a move that causes them to lose the competition if a winning move exists.<br><br>Constraints:<br>1  n, T  50<br><br>Input Format:<br>The first line contains an integer T, the number of test cases.<br>Each of the next T lines contains an integer 'n', the number of Land mines in a test case.<br><br>Output Format:<br>Print the output in a separate lines contains, 'FIRST' if the first terrorist is the winner. Otherwise print 'SECOND'.</p> 
answer

 #include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define solve cout<<"if else for";
using namespace std;
long DP[101];
bool dp(long x)
{
	if (DP[x]!=-1) return DP[x];
	bool res=!dp(x-2);
	if (x>3) res=res|(!dp(x-3));
	if (x>5) res=res|(!dp(x-5));
	DP[x]=res;
	return res;
}
int main()
{
	long nTest,n;
	memset(DP,-1,sizeof(DP));
	DP[1]=0;
	DP[2]=DP[3]=DP[5]=1;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		scanf("%ld",&n);
		puts(dp(n)?"FIRST":"SECOND");
	}
}

question

 <p><strong>Problem Description:</strong></p><p>Mano went shopping and bought items worth X dollors (1X100). Unfortunately, Mano only has a single 100 dollors note.</p><p>Since Mano is weak at maths, can you help Mano in calculating what money he should get back after paying 100 dollors for those items?</p><p><strong>Constraints:</strong></p><ul><li>1T100</li><li>1X100</li></ul><p><strong>Input Format:</strong></p><ul><li>First line will contain T, the number of test cases. Then the test cases follow.</li><li>Each test case consists of a single line containing an integer X, the total price of items Mano purchased.</li></ul><p><strong>Output Format:</strong></p><p>Print the output in a single line the money Mano has to receive back.</p> 
answer

 #include <stdio.h>
void solve(){}
int main()
{
    int x,t;
    scanf("%d",&t);
    while(t--){
        scanf("%d",&x);
        printf("%d\n",100-x);
    }
	return 0;
}

question

 <p>Question Description:<br>Sanjay Ramasamy is a chairman of the Airvoice company, and today he is rewarding his workers for their hard work by giving them additional allowances of company fund.<br><br>He have 'M' workers sitting at a line of desks, and each one has a performance grade. Sanjay want to give at least mini allowance(s) to each worker j (where 0 &lt;= j &lt;= M), but also give extra rewards to some of top performers. If two workers are sufficiently close to each other, then the worker with the higher grade must receive more allowances than the worker with the lower grade. Two workers are sufficiently close if the distance between them is less than or equal to 10, meaning worker 'j' is sufficently close to workers in the range [j-10, j+10].<br><br>Given the performance reviews for each of Sanjay's 'M' workers, find and print the minimum number of fund allowances Sanjay will need to grant to the workers. Assume the location of each worker is fixed.<br><br>Constraints:<br>1  M  10^5<br>1  gradej  10^5<br>1  minj  10^5<br><br>Input Format:<br>The first line contains an integer, M, denoting the number of workers.<br>The second line contains M integers separated by spaces, denoting gradej for worker 'j' (where 0 &lt;= j &lt;= M).<br>The third line contains 'M' integers separated by spaces, denoting minj for worker 'j' (where 0 &lt;= j &lt;= M).<br><br>Output Format:<br>Print the output in a single line contains, find the minimum number of fund allowances sanjay must grant.</p> 
answer

 #include <bits/stdc++.h>
#define fo1r for(i = 0; i < M; i++)
using namespace std;

typedef long long ll;

int main() {
  ll N;
  cin >> N;
  vector<ll> rat(N), low(N);
  for(ll& r : rat) cin >> r;
  for(ll& l : low) cin >> l;
  vector<ll> ord(N), cnt(N);
  for(ll i = 0; i < N; ++i) ord[i] = i;
  sort(ord.begin(), ord.end(), [&rat](ll a, ll b) {return rat[a] < rat[b];});
  ll res = 0;
  for(ll p : ord) {
    cnt[p] = low[p];
    for(ll i = max(0LL, p-10); i <= min(N+1,p+10); ++i) {
      if (rat[p] > rat[i])
        cnt[p] = max(cnt[p], cnt[i] + 1);
    }
    res += cnt[p];
  }
  cout << res << endl;
  return 0;
}

question

 <p>Question Description:</p><p>The N hobbits are planning to spend the night at Fahad's house. Fahad has <i>n</i> beds standing in a row and <i>m</i> pillows (<i>n</i><i>m</i>). Each hobbit needs a bed and at least one pillow to sleep, however, everyone wants as many pillows as possible. Of course, it's not always possible to share pillows equally, but any hobbit gets hurt if he has at least two pillows less than some of his neighbour's have.</p><p>Fahad will sleep on the <i>k</i>-th bed in the row. What is the maximum number of pillows he can have so that every hobbit has at least one pillow, every pillow is given to some hobbit and no one is hurt?</p><p>Constraints:</p><p>1<i>n</i><i>m</i>10<sup>9</sup></p><p>1<i>k</i><i>n</i></p><p>Input Format:</p><p>The only line contain three integers <i>n</i>, <i>m</i> and <i>k</i> the number of hobbits, the number of pillows and the number of Fahad's bed.</p><p>Output Format:</p><p>Print single integer&nbsp;the maximum number of pillows Fahad can have so that no one is hurt.</p> 
answer

 #include <iostream>
using namespace std;
int n,m,k,a=1,c=1;
int main() {
	cin>>n>>m>>k;
	m-=n;
	while(m>0){
		if(k+a<=n) c++;
		if(k-a>=1) c++;
		m-=c;
		a++;
	}
	cout<<a;
}

question

 <p>Question Description:</p><p>Define the <i>simple skewness</i> of a collection of numbers to be the collection's mean minus its median.&nbsp;</p><p>You are given a list of <i>n</i> (not necessarily distinct) integers.&nbsp;</p><p>Find the non-empty subset (with repetition) with the maximum simple skewness.</p><p>The mean of a collection is the average of its elements.&nbsp;</p><p>The median of a collection is its middle element when all of its elements are sorted, or the average of its two middle</p><p>elements if it has even size.</p><p>Constraints:</p><p>1<i>n</i>200 000</p><p>0<i>x<sub>i</sub></i>1000000</p><p>Input Format:</p><p>The first line of the input contains a single integer <i>n </i>the number of elements in the list.</p><p>The second line contains <i>n</i> integers <i>x<sub>i</sub></i> the <i>i</i>th element of the list.</p><p>Output Format:</p><p>In the first line, print a single integer k the size of the subset.</p><p>In the second line, print <i>k</i> integers&nbsp;the elements of the subset in any order.</p><p>If there are multiple optimal subsets, print any.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define nite double check(int pos,int l){return 1;}
const int N=2e5+5;int n,a[N];long long p[N],sum[N];double go(int mid,int k){double ret=sum[n]-sum[n-k];ret+=sum[mid]-sum[mid-k-1];ret/=(2*k+1);ret-=a[mid];return ret;}int main(){int i,j,k;cin>>n;for(i=1;i<=n;++i)cin>>a[i];sort(a+1,a+1+n);sum[0]=0;int l=1,r=0;double ret=-10;for(i=1;i<=n;++i)sum[i]=sum[i-1]+a[i];for(i=2;i<n;++i){k=0;for(j=20;j>=0;--j){k+=1<<j;if(i>n-k||i-k-1<0||go(i,k)<go(i,k-1))k-=1<<j;}if(ret<go(i,k)){ret=go(i,k);l=i;r=k;}}printf("%d\n",2*r+1);for(i=l-r;i<=l;++i)printf("%d ",a[i]);for(i=n-r+1;i<=n;++i)printf("%d ",a[i]);cout<<endl;}

question

 <p>Question Description:</p><p style="text-align:justify;">This is the easy version of the problem. The only difference is maximum value of A.</p><p style="text-align:justify;">Once in Vettayapuram aranmanai <i>Divan</i> found an array A consisting of positive integers. Now he wants to reorder the elements of A to maximize the value of the following function:</p><p style="text-align:justify;"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><munderover><mo></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>gcd</mi><mo></mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mspace width="thinmathspace">&nbsp;</mspace><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mspace width="thinmathspace">&nbsp;</mspace><mo></mo><mo>,</mo><mspace width="thinmathspace">&nbsp;</mspace><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>,</mo></math>where gcd(1,2,,) denotes the greatest common divisor of integers 1,2,,, and gcd()= for any integer .</p><p style="text-align:justify;">Reordering elements of an array means changing the order of elements in the array arbitrary, or leaving the initial order.</p><p style="text-align:justify;">Of course, <i>Divan</i> can solve this problem. However, he found it interesting, so he decided to share it with you.</p><p>Constraints:</p><p>1 N 10^5</p><p>1510^6</p><p>Input Format:</p><p>The first line contains a single integer N the size of the array A.</p><p>The second line contains N integers 1,2,, the array A.</p><p>Output Format:</p><p>Output the maximum value of the function that you can get by reordering elements of the array A.</p> 
answer

 #include<bits/stdc++.h>
#define int long long
using namespace std;
int const M=5000000;int i,j,n,s,x,e[M+100],f[M+100],d[M+100];
signed main(){
	cin>>n;
	for (i=1;i<=n;i++) scanf("%lld",&x),f[x]++;
	for (i=1;i<=M;i++)
		for (j=i;j<=M;j+=i)
			e[i]+=f[j];
	for (i=M;i>0;i--){
		for (s=0,j=i*2;j<=M;j+=i) s=max(s,d[j]-e[j]*i);
		d[i]=e[i]*i+s;
	} 
	printf("%lld\n",d[1]);
	return 0;
}

question

 <p style="text-align:justify;">Question Description:</p><p style="text-align:justify;">Adiththi likes drawing. She has drawn many graphs already, both directed and not. Recently she has started to work on a still-life interesting graph and apples.&nbsp;</p><p style="text-align:justify;">An undirected graph is called interesting, if each of its vertices belongs to one cycle only a funny ring and does not belong to any other cycles.&nbsp;</p><p style="text-align:justify;">A funny ring is a cycle that goes through all the vertices just once. Moreover, loops are funny rings too.</p><p style="text-align:justify;">She has already drawn the apples and some of the graph edges. But now it is not clear, how to connect the rest of the vertices to get an interesting graph as a result.&nbsp;</p><p style="text-align:justify;">The answer should contain the minimal amount of added edges. And furthermore, the answer should be the lexicographically smallest one.&nbsp;</p><p style="text-align:justify;">The set of edges (<i>x</i><sub>1</sub>,<i>y</i><sub>1</sub>),(<i>x</i><sub>2</sub>,<i>y</i><sub>2</sub>),...,(<i>x<sub>n</sub></i>,<i>y<sub>n</sub></i>), where <i>x<sub>i</sub></i><i>y<sub>i</sub></i>, is lexicographically smaller than the set (<i>u</i><sub>1</sub>,<i>v</i><sub>1</sub>),(<i>u</i><sub>2</sub>,<i>v</i><sub>2</sub>),...,(<i>u<sub>n</sub></i>,<i>v<sub>n</sub></i>), where <i>u<sub>i</sub></i><i>v<sub>i</sub></i>, provided that the sequence of integers <i>x</i><sub>1</sub>,<i>y</i><sub>1</sub>,<i>x</i><sub>2</sub>,<i>y</i><sub>2</sub>,...,<i>x<sub>n</sub></i>,<i>y<sub>n</sub></i> is lexicographically smaller than the sequence <i>u</i><sub>1</sub>,<i>v</i><sub>1</sub>,<i>u</i><sub>2</sub>,<i>v</i><sub>2</sub>,...,<i>u<sub>n</sub></i>,<i>v<sub>n</sub></i>.&nbsp;</p><p style="text-align:justify;">If you do not cope, Adiththi will eat you. ...eat you alive.</p><p style="text-align:justify;">Constraints:</p><p style="text-align:justify;">1N50</p><p style="text-align:justify;">0M2500</p><p style="text-align:justify;">1<i>x<sub>i</sub></i>, <i>y<sub>i</sub></i>N</p><p style="text-align:justify;">Input Format:</p><p>The first line of the input data contains a pair of integers N and M the amount of vertices and edges respectively.&nbsp;</p><p>The following lines contain pairs of numbers <i>x<sub>i</sub></i> and <i>y<sub>i</sub></i> the vertices that are already connected by edges.&nbsp;</p><p>The initial graph may contain multiple edges and loops.</p><p style="text-align:justify;">Output Format:</p><p>In the first line output YES or NO: if it is possible or not to construct an interesting graph.&nbsp;</p><p>If the answer is YES, in the second line output <i>k</i> the amount of edges that should be added to the initial graph.&nbsp;</p><p>Finally, output <i>k</i> lines: pairs of vertices <i>x<sub>j</sub></i> and <i>y<sub>j</sub></i>, between which edges should be drawn.&nbsp;</p><p>The result may contain multiple edges and loops. <i>k</i> can be equal to zero.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define ggg int find(int p) unite(int p,int q) cin>>u>>v;
int i,j,x,y,n,m,ans,f[502],a[502];
int find(int x){return (f[x]==x)?x:f[x]=find(f[x]);}
int main (){
	scanf("%d %d",&n,&m);
	if (m>n) return printf("NO\n"),0;
	for (i=1;i<=n;i++) f[i]=i;
	for (i=1;i<=m;i++){
		scanf("%d %d",&x,&y);a[x]++;a[y]++;
		if (find(x)==find(y)&&i!=n) return printf("NO\n"),0;
		f[find(x)]=find(y);
	}
	for (i=1;i<=n;i++)
		if (a[i]>2) 
			return printf("NO\n"),0;
	printf("YES\n%d\n",n-m);
	for (i=1;i<=n;i++)
		while (a[i]<2){
			ans=i+(n!=1);
			for (j=ans;j<=n;j++)
				if (a[j]<2&&(n<=2||m+1==n||find(i)!=find(j)))
					{printf("%d %d\n",i,j);m++;a[i]++;a[j]++;f[find(i)]=find(j);break;}
	}
	return 0;
}

question

 <p>We call two numbers x and y <i>similar</i> if they have the same parity (the same remainder when divided by 2), or if |xy|=1. For example, in each of the pairs (2,6), (4,3), (11,7), the numbers are similar to each other, and in the pairs (1,4), (3,12), they are not.</p><p>You are given an array a of n (n is even) positive integers. Check if there is such a partition of the array into pairs that each element of the array belongs to exactly one pair and the numbers in each pair are similar to each other.</p><p>For example, for the array a=[11,14,16,12], there is a partition into pairs (11,12) and (14,16). The numbers in the first pair are similar because they differ by one, and in the second pair because they are both even.</p><p><strong>Input</strong></p><p>The firstline contains a single integer t (1t1000)&nbsp; the number of test cases. Then t test cases follow.</p><p>Each test case consists of two lines.</p><p>The first line contains an <strong>even</strong> positive integer n (2n50)&nbsp; length of array a.</p><p>The second line contains n<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math>&nbsp;positive integers a1,a2,,an (1ai100).</p><p><strong>Output</strong></p><p>For each test case print:</p><ul><li>YES if the such a partition exists,</li><li>NO otherwise.</li></ul><p>The letters in the words YES and NO can be displayed in any case.</p> 
answer

 #include <bits/stdc++.h>
using namespace std;
int i,k,m,n,t,a[60];
int main()
{   
    scanf("%d",&t);
while(t!=0) {
        cin>>n;
        for(i=k=m=0;i<n;i++)
        {
            cin>>a[i];
            if(a[i]&1)m++;
        }
        sort(a,a+n);
        for(i=0;++i<n;)
        {
            if(a[i]-a[i-1]==1)k++;
        }
        if(m&1&&!k)cout<<"NO"<<endl;
        else cout<<"YES"<<endl;
        t--;
    }
    return 0;
    cout<<"int t,n,q,i,j,w,a[55],b[55];";
}

question

 <p>The annual snake festival is upon us, and all the snakes of the kingdom have gathered to participate in the procession. Chef has been tasked with reporting on the procession, and for this he decides to first keep track of all the snakes. When he sees a snake first, it'll be its Head, and hence he will mark a 'H'. The snakes are long, and when he sees the snake finally slither away, he'll mark a 'T' to denote its tail. In the time in between, when the snake is moving past him, or the time between one snake and the next snake, he marks with '.'s.</p><p>Because the snakes come in a procession, and one by one, a valid report would be something like "..H..THTH.T.", or "", or "HT", whereas "TH..H.T", "H..T..H", "H..H..T..T" would be invalid reports (See explanations at the bottom).</p><p>Formally, a snake is represented by a 'H' followed by some (possibly zero) '.'s, and then a 'T'. A valid report is one such that it begins with a (possibly zero length) string of '.'s, and then some (possibly zero) snakes between which there can be some '.'s, and then finally ends with some (possibly zero) '.'s.</p><p>Chef had binged on the festival food and had been very drowsy. So his report might be invalid. You need to help him find out if his report is valid or not.</p><h3>Input</h3><ul><li>The first line contains a single integer, R, which denotes the number of reports to be checked. The description of each report follows after this.</li><li>The first line of each report contains a single integer, L, the length of that report.</li><li>The second line of each report contains a string of length L. The string contains only the characters '.', 'H', and 'T'.</li></ul><h3>Output</h3><ul><li>For each report, output the string <strong>Valid</strong> or <strong>Invalid</strong> in a new line, depending on whether it was a valid report or not.</li></ul><h3>Constraints</h3><ul><li>1R500</li><li>1L500</li></ul> 
answer

 #include<stdio.h>
int main(){
int T;
	scanf("%d",&T);
	while(T--){
	    int n,i,count=0;
	    scanf("%d",&n);
	    char s[n];
	    scanf("%s",s);
	    for(i=0;i<n;i++){
	        if(s[i]=='.')
	            continue;
	        else if(s[i]=='H')
	            count++;
	        else if(s[i]=='T')
	            count--;
	        if(count<0||count>1)
	            break;
	    }
	    if(count==0&&n==i)
	        printf("Valid\n");
	    else
	        printf("Invalid\n");
	}
	return 0;
}

question

 <p style="text-align:justify;">Question Description:</p><p style="text-align:justify;">Nowadays the one-way traffic is introduced all over the world in order to improve driving safety and reduce traffic jams.</p><p style="text-align:justify;">The government of Tamilnadu decided to keep up with new trends. Formerly all <i>n</i> cities of Tamilnadu were connected by <i>n</i> two-way roads in the ring, i. e. each city was connected directly to exactly two other cities, and from each city it was possible to get to any other city.&nbsp;</p><p style="text-align:justify;">Government of Tamilnadu introduced one-way traffic on all <i>n</i> roads, but it soon became clear that it's impossible to get from some of the cities to some others. Now for each road is known in which direction the traffic is directed at it, and the cost of redirecting the traffic.&nbsp;</p><p style="text-align:justify;">What is the smallest amount of money the government should spend on the redirecting of roads so that from every city you can get to any other?</p><p style="text-align:justify;">Constraints:</p><p style="text-align:justify;">3N100</p><p style="text-align:justify;">1<i>a<sub>i</sub></i>,<i>b<sub>i</sub></i><i>n</i>,<i>a<sub>i</sub></i><i>b<sub>i</sub></i></p><p style="text-align:justify;">1<i>c<sub>i</sub></i>100</p><p style="text-align:justify;">Input Format:</p><p style="text-align:justify;">The first line contains integer N amount of cities (and roads) in Tamilnadu. Next N lines contain description of roads.&nbsp;</p><p style="text-align:justify;">Each road is described by three integers <i>a<sub>i</sub></i>, <i>b<sub>i</sub></i>, <i>c<sub>i</sub></i> road is directed from city <i>a<sub>i</sub></i> to city <i>b<sub>i</sub></i>, redirecting the traffic costs <i>c<sub>i</sub></i>.</p><p style="text-align:justify;">Output Format:</p><p style="text-align:justify;">Output single integer the smallest amount of money the government should spend on the redirecting of roads so that from every city you can get to any other.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int s[105],e[105];
int main(){
	int n,ans=0,res=0;cin>>n;
	while(n--){
		int a,b,c;cin>>a>>b>>c;
		if(s[a]||e[b])res+=c,s[b]=e[a]=1;
		else s[a]=e[b]=1;
		ans+=c;
	}
	cout<<min(res,ans-res);
	
}

question

 <p>Little Petya loves presents. His mum bought him two strings of the same size for his birthday.&nbsp;</p><p>The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.</p><p><strong>Input</strong></p><p>Each of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.</p><p><strong>Output</strong></p><p>If the first string is less than the second one, print "-1". If the second string is less than the first one, print "1". If the strings are equal, print "0". Note that the letters' case is not taken into consideration when the strings are compared.</p> 
answer

 #include <bits/stdc++.h>
#include<string.h>
char a[100],b[100];
int main()
{
    std::cin>>a>>b;
    std::cout<<"'"<<strcasecmp(a,b)<<"'";}

question

 <p>Question Description:</p><p>Alpha company is working on a new version of its most popular text editor Bord 2010. Bord, like many other text editors, should be able to print out multipage documents.&nbsp;</p><p>A user keys a sequence of the document page numbers that he wants to print out (separates them with a comma, without spaces).</p><p>Your task is to write a part of the program, responsible for standardisation of this sequence. Your program gets the sequence, keyed by the user, as input.&nbsp;</p><p>The program should output this sequence in format <i>l</i><sub>1</sub>-<i>r</i><sub>1</sub>,<i>l</i><sub>2</sub>-<i>r</i><sub>2</sub>,...,<i>l<sub>k</sub></i>-<i>r<sub>k</sub></i>, where <i>r<sub>i</sub></i>+1&lt;<i>l<sub>i</sub></i><sub>+1</sub> for all <i>i</i> from 1 to <i>k</i>-1, and <i>l<sub>i</sub></i><i>r<sub>i</sub></i>.</p><p>The new sequence should contain all the page numbers, keyed by the user, and nothing else.&nbsp;</p><p>If some page number appears in the input sequence several times, its appearances, starting from the second one, should be ignored.&nbsp;</p><p>If for some element <i>i</i> from the new sequence <i>l<sub>i</sub></i>=<i>r<sub>i</sub></i>, this element should be output as <i>l<sub>i</sub></i>, and not as <i>l<sub>i</sub></i>-<i>l<sub>i</sub></i>.</p><p>For example, sequence 1,2,3,1,1,2,6,6,2 should be output as 1-3,6.</p><p>Constraints:</p><p>1S10^5</p><p>Input Format:</p><p>The only line contains the sequence, keyed by the user.&nbsp;</p><p>The sequence contains at least one and at most 100 positive integer numbers.&nbsp;</p><p>It's guaranteed, that this sequence consists of positive integer numbers, not exceeding 1000, separated with a comma, doesn't contain any other characters, apart from digits and commas, can't end with a comma, and the numbers don't contain leading zeroes.&nbsp;</p><p>Also it doesn't start with a comma or contain more than one comma in a row.</p><p>Output Format:</p><p>Output the sequence in the required format.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define solve cout<<"cin>>s; string"
bool m[1111];
int main(){
	int x(0),s(0),u(0),v(0);
	while(scanf("%d%*c",&x)!=EOF) m[x]=true;
	for(auto i=0;i<1111;i++){
		if(m[i]){
			if(!m[i-1]) u=i;
		}else if(m[i-1]){
			v=i-1;
			if(s) cout<<",";
			else s=1;
			if(u==v) cout<<u;
			else cout<<u<<"-"<<v;
		}
	}
	
}

question

 <p><strong>Problem statement</strong></p><p>Sherlock rolls a <strong>N</strong> faced die <strong>M</strong> times. He adds all the numbers he gets on all throws. What is the probability that he has a sum of <strong>K</strong>.</p><p>A <strong>N</strong> faced die has all numbers from <strong>1</strong> to <strong>N</strong> written on it and each has equal probability of arriving when dice is thrown.</p><p><strong>Input</strong><br>First line <strong>T</strong>, the number of testcases. Each testcase consists of <strong>M</strong>, <strong>N</strong> and <strong>K</strong> in one line.</p><p><strong>Output</strong><br>For each testcase, print required probability in scientific notation as defined follows:<br>Output should be of the form "<strong>x y</strong>" where <strong>x</strong> is a floating point integer less than <strong>10</strong> and greater than or equal to <strong>1</strong> and <strong>y</strong> is a integer. This notation is equivalent to <strong>x * 10<sup>-y</sup></strong>. <strong>x</strong> should be rounded and output till 3 decimal digits.<br>However, if probability is <strong>0</strong>, output "<strong>0.000 0</strong>".</p><p>Examples: If output is supposed to be 0.0034567, output should be "3.457 3".<br>If output is supposed to be 0.3034567, output should be "3.034 1".</p><p><strong>Constraints</strong><br>1  T  10<br>1  N, M  50<br>1  K  10000</p><p><strong>Sample Input</strong></p><p>2
</p><p>1 5 2
</p><p>2 3 2
</p><p><strong>Sample Output</strong></p><p>2.000 1
</p><p>1.111 1
</p><p><strong>Explanation</strong></p><p>For first testcase, sum=1,2,3,4,5 are all equally probable. Hence probability is 0.2. For second testcase: (1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3) are all possible ways. Out of these 1 has sum 2. So 1/9 is the answer.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
double dp[55][10005];
double power(double x,int y)
{
    double res=1.0;
    while(y)
    {
        if(y&1)
        res*=x;
        x*=x;
        y/=2;
    }
    return res;
}
int main()
{   
    int t;
    cin>>t;
    while(t--)
    {   int m,n,k;
        cin>>m>>n>>k;
		
		for(int i=0;i<=m;i++) for(int j=0;j<=k;j++) dp[i][j]=0.0;
        double ans=power(1.0/(n*1.0),m);
        dp[0][0]=ans;
        for(int i=1;i<=m;i++)
         {
         for(int j=1;j<=k;j++)
		 {
			 for(int l=1;l<=min(n,j);l++)
			 {
				 if(j-l>=0)
				 dp[i][j]+=dp[i-1][j-l];
			 }
		 }
        } 
         int y=0;
         ans=dp[m][k];
         while(ans<1.0-(1e-100)&&y<10000)
         ans*=10.0,y++;
         if(y==10000) y=0;
         cout<<setprecision(3)<<fixed<<ans<<" ";
        cout<<y<<"\n";
    }
}

question

 <p style="text-align:justify;">Question Description:</p><p style="text-align:justify;">The VSR company won another tender for an important state reform in Bombay.</p><p style="text-align:justify;">There are <i>n</i> cities in Bombay, some pairs of the cities are connected by roads. Each road has its price. One can move along any road in any direction.&nbsp;</p><p style="text-align:justify;">The VSR team should carry out the repair works on some set of roads such that one can get from any city to any other one moving only along the repaired roads.&nbsp;</p><p style="text-align:justify;">Moreover, this set should contain exactly <i>k</i> capital roads (that is, the roads that start or finish in the capital). The number of the capital is 1.</p><p style="text-align:justify;">As the budget has already been approved, the VSR Company will profit by finding the set with minimum lengths of roads.</p><p style="text-align:justify;">Constraints:</p><p style="text-align:justify;">1<i>n</i>5000</p><p style="text-align:justify;">0<i>m</i>10<sup>5</sup></p><p style="text-align:justify;">0<i>k</i>&lt;5000</p><p style="text-align:justify;">1<i>a<sub>i</sub></i>,<i>b<sub>i</sub></i><i>n</i>; 1<i>w</i>10<sup>5</sup></p><p style="text-align:justify;">Input Format:</p><p>The first input line contains three integers <i>n</i>,<i>m</i>,<i>k</i>, where <i>n</i> is the number of cities in the country, <i>m</i> is the number of roads in the country, <i>k</i> is the number of capital roads in the required set.&nbsp;</p><p>Then <i>m</i> lines enumerate the roads in question.&nbsp;</p><p>Each road is specified by three numbers <i>a<sub>i</sub></i>,<i>b<sub>i</sub></i>,<i>w<sub>i</sub></i>, where <i>a<sub>i</sub></i>,<i>b<sub>i</sub></i> are the numbers of cities linked by a road and <i>w<sub>i</sub></i> is its length.</p><p>Between each pair of cities no more than one road exists.&nbsp;</p><p>There are no roads that start and finish in one city.&nbsp;</p><p>The capital's number is 1.</p><p style="text-align:justify;">Output Format:</p><p style="text-align:justify;">In the first line print the number of roads in the required set.&nbsp;</p><p style="text-align:justify;">The second line should contain the numbers of roads included in the sought set.&nbsp;</p><p style="text-align:justify;">If the sought set does not exist, print -1.</p> 
answer

 #include<bits/stdc++.h>
#define maxn 5005
#define maxm 100005
using namespace std;
int n,m,k,f[maxn],ans,num,cnt,t[maxn];
struct node{
	int x,y,w,p,id;
	bool operator < (const node &B)const{return p==B.p?x<B.x:p<B.p;}
}e[maxm];
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
void Kruskal(int mid){
	for(int i=1;i<=m;i++) e[i].p=e[i].w+(e[i].x==1?mid:0);
	sort(e+1,e+1+m);
	for(int i=1;i<=n;i++) f[i]=i;
	ans=num=cnt=t[0]=0;
	for(int i=1,x,y;i<=m&&cnt<n-1;i++)
		if((x=find(e[i].x))!=(y=find(e[i].y))&&num+(e[i].x==1)<=k)
			f[x]=y,ans+=e[i].p,num+=(e[i].x==1),cnt++,t[++t[0]]=e[i].id;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w),e[i].id=i;
		if(e[i].x>e[i].y) swap(e[i].x,e[i].y);
	}
	Kruskal(-100000);
	if(cnt<n-1||num<k) return puts("-1"),0;
	int l=-100000,r=100000,mid;
	while(l<r){
		Kruskal(mid=(l+r+1)>>1);
		if(num>=k) l=mid;
		else r=mid-1;
	}
	Kruskal(l);
	printf("%d\n",t[0]);
	for(int i=1;i<=t[0];i++) printf("%d%c",t[i], i==t[0]?10:32);
}

question

 <p>Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.</p><p>The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+3.</p><p>You've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.</p><p><strong>Input</strong></p><p>The first line contains a non-empty string <i>s</i>  the sum Xenia needs to count. String <i>s</i> contains no spaces. It only contains digits and characters "+". Besides, string <i>s</i> is a correct sum of numbers 1, 2 and 3. String <i>s</i> is at most 100 characters long.</p><p><strong>Output</strong></p><p>Print the new sum that Xenia can count.</p> 
answer

 #include <bits/stdc++.h>
#define solve cout<<"y=strlen(a); {if(a[i-2]>a[i]) {t=a[i-2];"
using namespace std;int a[105],n,j=2;
int main(){while(cin>>a[n++]);sort(a,a+n);cout<<a[1];
for(;j<n;j++)cout<<'+'<<a[j];}

question

 <p style="text-align:justify;">Question Description:</p><p style="text-align:justify;">The houses are numbered from 1 to N. Underground water pipes connect these houses together. Each pipe has certain direction (water can flow only in this direction and not vice versa), and diameter (which characterises the maximal amount of water it can handle).</p><p style="text-align:justify;">For each house, there is at most one pipe going into it and at most one pipe going out of it. With the new semester starting, LWT student and dorm resident, Lal, wants to install tanks and taps at the dorms.&nbsp;</p><p style="text-align:justify;">For every house with an outgoing water pipe and without an incoming water pipe, Lal should install a water tank at that house.&nbsp;</p><p style="text-align:justify;">For every house with an incoming water pipe and without an outgoing water pipe, Lal should install a water tap at that house.&nbsp;</p><p style="text-align:justify;">Each tank house will convey water to all houses that have a sequence of pipes from the tank to it. Accordingly, each tap house will receive water originating from some tank house.</p><p style="text-align:justify;">In order to avoid pipes from bursting one week later (like what happened last semester), Lal also has to consider the diameter of the pipes.&nbsp;</p><p style="text-align:justify;">The amount of water each tank conveys should not exceed the diameter of the pipes connecting a tank to its corresponding tap.&nbsp;</p><p style="text-align:justify;">Lal wants to find the maximal amount of water that can be safely conveyed from each tank to its corresponding tap.</p><p style="text-align:justify;">Constraints:</p><p style="text-align:justify;">1N1000</p><p style="text-align:justify;">0PN</p><p style="text-align:justify;">1<i>a<sub>i</sub></i>,<i>b<sub>i</sub></i><i>n</i>,<i>a<sub>i</sub></i><i>b<sub>i</sub></i></p><p style="text-align:justify;">1<i>d<sub>i</sub></i>10<sup>6</sup></p><p style="text-align:justify;">Input Format:</p><p style="text-align:justify;">The first line contains two space-separated integers N and P the number of houses and the number of pipes correspondingly.</p><p style="text-align:justify;">Then <i>p</i> lines follow the description of <i>p</i> pipes. The <i>i</i>-th line contains three integers <i>a<sub>i</sub></i> <i>b<sub>i</sub></i> <i>d<sub>i</sub></i>, indicating a pipe of diameter <i>d<sub>i</sub></i> going from house <i>a<sub>i</sub></i> to house <i>b<sub>i</sub></i>.</p><p style="text-align:justify;">It is guaranteed that for each house there is at most one pipe going into it and at most one pipe going out of it.</p><p style="text-align:justify;">Output Format:</p><p style="text-align:justify;">Print integer <i>t</i> in the first line the number of tank-tap pairs of houses.</p><p style="text-align:justify;">For the next <i>t</i> lines, print 3 integers per line, separated by spaces: <i>tank<sub>i</sub></i>, <i>tap<sub>i</sub></i>, and <i>diameter<sub>i</sub></i>, where <i>tank<sub>i</sub></i><i>tap<sub>i</sub></i> (1<i>i</i><i>t</i>).</p><p style="text-align:justify;">Here <i>tank<sub>i</sub></i> and <i>tap<sub>i</sub></i> are indexes of tank and tap houses respectively, and <i>diameter<sub>i</sub></i> is the maximum amount of water that</p><p style="text-align:justify;">can be conveyed.&nbsp;</p><p style="text-align:justify;">All the <i>t</i> lines should be ordered (increasingly) by <i>tank<sub>i</sub></i>.</p> 
answer

 #include <iostream>
using namespace std;
#define N 1010
int a[N],w[N],b[N];
int main()
{
	int n,p,x,y,z,i,t,min;
	cin>>n>>p;
	while(p--)
	{
		cin>>x>>y>>z;
		a[x]=y;
		w[x]=z;
		b[x]++;
		b[y]+=2;
	}
	for(t=0,i=1;i<=n;i++)if(b[i]==1)t++;
	printf("%d\n",t);
	for(i=1;i<=n;i++)if(b[i]==1)
	{
		min=w[i];
		t=a[i];
		while(a[t]!=0)
		{
			if(w[t]<min)min=w[t];
			t=a[t];
		}
		printf("%d %d %d\n",i,t,min);
	}
	return 0;
}

question

 <p>So, the New Year holidays are over. Santa Claus and his colleagues can take a rest and have guests at last. When two "New Year and Christmas Men" meet, thear assistants cut out of cardboard the letters from the guest's name and the host's name in honor of this event. Then the hung the letters above the main entrance. One night, when everyone went to bed, someone took all the letters of our characters' names. Then he may have shuffled the letters and put them in one pile in front of the door.</p><p>The next morning it was impossible to find the culprit who had made the disorder. But everybody wondered whether it is possible to restore the names of the host and his guests from the letters lying at the door? That is, we need to verify that there are no extra letters, and that nobody will need to cut more letters.</p><p>Help the "New Year and Christmas Men" and their friends to cope with this problem. You are given both inscriptions that hung over the front door the previous night, and a pile of letters that were found at the front door next morning.</p><p><strong>Input</strong></p><p>The input file consists of three lines: the first line contains the guest's name, the second line contains the name of the residence host and the third line contains letters in a pile that were found at the door in the morning. All lines are not empty and contain only uppercase Latin letters. The length of each line does not exceed 100.</p><p><strong>Output</strong></p><p>Print "YES" without the quotes, if the letters in the pile could be permuted to make the names of the "New Year and Christmas Men". Otherwise, print "NO" without the quotes.</p> 
answer

 #include<bits/stdc++.h>
#define solve cout<<" l=strlen(s); g=strlen(p);  char s[102],k[102],p[102],fun; h=strlen(k);"
int main(){
    std::string a,b,c;
    std::cin>>a>>b>>c;
    a+=b;std::cout<<(a.size() == c.size() && is_permutation(a.begin(),a.end(),c.begin())? "YES" : "NO");}

question

 <p><strong>Problem Description:</strong></p><p>Village Cooking Channel is the famous youtube channel in the world, and the reason for that is his special, Homemade red chilly masala. red chilly can be grown in rectangular patches of any side lengths.</p><p>However, The owner only has a limited amount of land.Consider the entire town of Pudhukottai to be consisting of cells in a rectangular grid of positive coordinates.The owner own all cells (x,y) that satisfy xyN</p><p>As an example if N=4, The owner owns the following cells:(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(3,1),(4,1)The owner can only grow Red chilly in rectangular patches consisting only of cells which belong to him.</p><p>Also, if he uses a cell, he must use it entirely. He cannot use only a portion of it.</p><p><strong>Constraints:</strong></p><p>1  T  5</p><p>1  N  10^10</p><p><strong>Input Format:</strong></p><p>The first line of the input contains T, the number of test cases.The next T lines of input contains one integer N.</p><p><strong>Output Format:</strong></p><p>Print the output the number of unique patches of rectangular land that he can grow Red chilly in!</p><p>Since this number can be very large, output it modulo 1000000007.</p> 
answer

 #include <iostream>
#include<math.h>
using namespace std;
#define solve cout<<"for(i=1;i<=x;i++) ll n,i,ans=0,x;"
#define mod 1000000007 
#define int1 long long
void solve2(){}
int main() {
	int T;
	int1 N;
	cin>>T;
	while(T--)
	{
	   int1  ans=0;
	    cin>>N;
	    for(int1 i=1;i<sqrt(N);i++)
	    {
	        int1 y=(N/i)%mod;
	        ans+=((i*(y+i+1))%mod)*((y-i));
	        ans=ans%mod;
	    }
	    for(int1 i=1;i<=sqrt(N);i++)
	    {
	        ans+=(i*i)%mod;
	        ans=ans%mod;
	    }
	    cout<<ans<<endl;
	}}

question

 <p><strong>Problem Description:</strong></p><p>As the 'The Dark Knight' Movie is over, Joker has no job. As he wants to earn money at short time, (he wants everything immediately!), he decided to ATMs. He wants to take calculated risks, and grab as much money as possible. But his friends - Spiderman and Superman have decided upon a tolerable probability P of getting caught. They think that it would be safer if he robs a subset of the ATMs under probablity P.</p><p>&nbsp;</p><p><strong>Constraints:</strong></p><p>1  T  100</p><p>0 &lt; N  100</p><p>0 &lt; Mj  100</p><p><strong>Input Format:</strong></p><p>Input starts with an integer T, denoting the number of test cases.</p><p>Each case contains a real number P, the probability as described above, and an integer N, the number of ATMs he is planning to rob.</p><p>Then follow N lines, where line j gives an integer Mj and a real number pj . ATM j contains Mj million dollars, and the probability of getting caught if he decides to rob ATM j is pj. A bank goes bankrupt if it is robbed, and you may assume that all the given probabilities are independent.</p><p><strong>Output Format:</strong></p><p>Find the maximum number of millions he can expect to get while the probability of getting caught is less than P.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;

#define LL long long
#define PII pair<int,int>
#define PLL pair<LL,LL>
#define MP make_pair
#define F first
#define S second
#define INF INT_MAX

#define ALL(x) (x).begin(), (x).end()
#define DBG(x) cerr << __LINE__ << " says: " << #x << " = " << (x) << endl

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

template<class TIn>
using indexed_set = tree<TIn, null_type, less<TIn>,rb_tree_tag, tree_order_statistics_node_update>;


const int nmax = 2e5+7;
const LL LINF = 1e17;

template<class T>
string to_str(T x)
{
    stringstream ss;
    ss<<x;
    return ss.str();
}


double dp[10005]; 
int money[105];
double p[105];

int main()
{

    int tc;
    cin>>tc;

    for(int qq=1; qq<=tc; qq++)
    {
        memset(dp,0,sizeof dp);

        int n;
        double thresh;
        cin>>thresh>>n;

        LL sum = 0;

        for(int i=1;i<=n;i++)
            cin>>money[i]>>p[i] , sum += money[i];

        dp[0] = 1.0; /** Probability of robbing 0 million **/

        for(int i=1;i<=n;i++)
            for(int s=sum;s-money[i]>=0;s--)
                dp[s] = max(dp[s],dp[s-money[i]]*(1-p[i])); /** As prob of not getting caught , So, (1-p[i]) is multiplied **/

        for(int s=sum;s>=0;s--)
            if(1-dp[s]<thresh) /** Prob of getting caught < threshold value **/
                {cout<<"Line "<<qq<<": "<<s<<endl;break;}

    }

    return 0;
    cout<<"for(i=0;i<n;i++)sum+=million[i];for(i=sum;i>=1;i--)";
}

question

 <p><strong>Problem Description:</strong></p><p>Shanmugam gave some White Forest Cakes to students for their extraordinary performances. A White Forest Cake is a cube shaped thing, which has length, width and height. All the students got the same amount of White Forest Cakes; their dimensions may be different but the volumes are the same.</p><p>Now some of the students are claiming that there is one White Forest Cake thief among them. So, it's not an easy task for me to find the White Forest Cake thief, so I am asking Anbu's help.</p><p>Shanmugam has given the names of the students and the dimensions of their White Forest Cakes; Anbu have to find the name of the White Forest Cake thief. Anbu can assume that there can be at most one thief and if there is a thief, he took some portion of the White Forest Cake from exactly another student (not students).</p><p>&nbsp;</p><p><strong>Constraints:</strong></p><p>1  T  100</p><p>2  n  100</p><p><strong>Input Format:</strong></p><p>Input starts with an integer T, denoting the number of test cases.</p><p>Each case starts with a line containing an integer n denoting the number of students. Each of the next n lines contains a name and three integers denoting the length, width and height of his/her current White Forest Cake share. Names are strings containing alphanumeric characters and the length of a name is between 1 and 20. And length, width and height will lie in the range [1, 100].</p><p><strong>Output Format:</strong></p><p>Print the output in a separate lines contains to find if no thief is found, print no thief. Otherwise print x took White Forest Cake from y where x is the name of the White Forest Cake thief, and y is the name of the person from whom the White Forest Cake was taken.</p> 
answer

 #include <stdio.h>
#include <string.h>
int main ()
{
   int a, b, c, cas, k, n, v, max, min, i;
   char str[100], thief[100], s[100];
   scanf (" %d", &cas);
   for (k = 1; k <= cas; k++) {
      scanf (" %d %s %d %d %d", &n, thief, &a, &b, &c);
      max = a * b * c;
      min = max;
      strcpy (s, thief);
      for (i = 1; i < n; i++) {
         scanf (" %s %d %d %d", str, &a, &b, &c);
         v = a * b * c;
         if (v > max) {
            strcpy (thief , str);
            max = v;
         }
         else if (v < min) {
            strcpy (s , str);
            min = v;
         }
      }
      if (max == min) printf ("Line %d: no thief\n", k);
      else printf ("Line %d: %s took chocolate from %s\n", k, thief, s);
   }
   return 0;
   printf("for(i=0;i<size-1;i++)");
}

question

 <p>Problem Description:<br>VIBGYOR isn't just an acronym, it's a way of life for Nippon Paint India Pvt Ltd. The owner is considering modernizing his paint mixing equipment with a computerized model. He's hired you to code the prototype. Your simple program will need to correctly output the right color based on the blends he's given you.</p><p>Example &nbsp;Colors</p><p>Primary colors  RED, BLUE, YELLOW,&nbsp;</p><p>secondary Colors ORANGE, PURPLE, GREEN</p><p>Tertiary Colors  LIGHT RED, DARK RED, LIGHT PURPLE, DARK PURPLE, LIGHT BLUE, DARK BLUE, LIGHT GREEN, DARK GREEN, LIGHT YELLOW, DARK YELLOW, LIGHT ORANGE, DARK ORANGE</p><p><br>Input Format:<br>You will receive one to five lines of color combinations consisting of primary colors and secondary colors as well as black and white to make "dark" and "light" colors. The full science of colorisation and pigments will be implemented next, if your prototype is successful.<br><br>Output Format:<br>Print the output in a separate lines contains, Your program should output the correct color depending on what two colors were "mixed" on the line. Primary colors should mix together to create secondary colors. Anything mixed with "WHITE" or "BLACK" should be output as either "LIGHT X" or "DARK X" where X is the color "WHITE" or "BLACK" were mixed with. Anything mixed with itself won't change colors. You are guaranteed not to receive incompatible colors, or colors not listed in the color wheels shown above (aside from "WHITE" and "BLACK").</p><p>&nbsp;</p><p>Refer logical test cases for your reference.&nbsp;</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
void arr()
{
    return;
}
int main()


    
{ 
    
        string ss[] = {"RED", "BLUE", "PURPLE", "YELLOW", "ORANGE" "GREEN"};
            string s,s1;
            int t = 4;
            while(t--)
            {
                
                  cin>>s>>s1;
                  //cout<<s<<" "<<s1;
                if(s == ss[0] && s1 == ss[3])
            
                    cout<<"ORANGE";
            
                    else if(s == ss[1] && s1 == ss[3]) cout<<"GREEN";
                    else if(s == ss[1] && s1== ss[0]) cout<<"PURPLE";
                    else if(s == "BLACK") cout<<"DARK"<<" "<<s1;
                     else if(s1 == "BLACK") cout<<"DARK"<<" "<<s;
                     else if(s1 == "WHITE") cout<<"LIGHT"<<" "<<s;
                      else if(s == "WHITE") cout<<"LIGHT"<<" "<<s1;
                      else if(s1 == s)cout<<s;
                      else cout<<"N/A";
                       cout<<"\n";

                 }


   return 0;
   cout<<"if(strcmp(c,colors[i])==0) for(i=0;i<8;i++) char mixes[8][8][32] char colors[8][32]";
}

question

 <p><strong>Problem Description:</strong></p><p>Fry is suspicious that the hard drive he just bought for his computer said 1EB on the box, but when he plugged it into his computer the operating system says it only has 931PB of space. Leela says that's because hard drive marketing uses base-10 to calculate space, but computer science (and operating systems) use base-2 (and always have). So, using base-10, 1 Exabyte (EB) would be 10^18 (1,000,000,000,000,000,000) bytes. But in base-2 it would be 2^60 (1,152,921,504,606,846,976) bytes. Most humans use base-10 when counting, so there is confusion. (Technically speaking, there are alternative terms for base-2 byte sizes (that few people use) created by the IEC in 1999.) Help Leela explain it to Fry by writing a program that will take storage space given in base-10, and convert it to base-2 using the tables below for reference.</p><p><strong>Input Format:</strong></p><p>You will receive a computer hard drive size as a whole integer, a space, then a 2-letter size code reported in Base-10 SI Units from the marketing text on the box. Your program should then convert to the base-2 Binary size the hard drive will show as available space in the operating system rounded to the nearest 2 decimal places in the largest binary size you can express a whole number in (e.g. do not write 1030 MiB, write 1.01 GiB)</p><figure class="image"><img src="data:image/png;base64,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3drV6Nl8qrsR3J5OouMXBEAABEBgkARGze6O2u4wXndnx04xONS8TnEMAiAwngROHRQ7/r8Hxf/7qSfEP/wXIVglpjbfIjb9P9cXt4JTkKH8csOuZJq9V/zVlj9qrDPdQfIL8fLf/In4wJ8dED9vovN/5l/EY396pfjIV88fyWe1htLskAkIgAAIjC2BEbS7xq4tEZfveEo8/dHfGIFHmNhYYSQeE4t3CDjUcTa4AwIgAAIgAAIgAAIgAAIgAAIgAAJRAnCoo2hwAwRAAARAAARAAARAAARAAARAAATiBOBQx9ngDgiAAAiAAAiAAAiAAAiAAAiAAAhECcChjqLBDRAAARAAARAAARAAARAAARAAARCIE4BDHWeDOyAAAiAAAiAAAiAAAiAAAiAAAiAQJQCHOooGN0AABEAABEAABEAABEAABEAABEAgTgAOdZwN7oAACIAACIAACIAACIAACIAACIBAlAAc6iga3AABEAABEAABEAABEAABEAABEACBOAE41HE2uAMCIAACIAACIAACIAACIAACIAACpQSkuot/YIA2MEJt4MCBA5L/tVot1N8I1R907vjZnMsuu4x32fbxMNvBYuc/zLIir/HrX02oc98u6/MmyAUZ0B/QBtw2UDDGfbigGLuZ4Bw80Aaa3wZ8ww2Huvl1hn413nW02A7tYueP9j/e7X8c6t+3y3Co0ebHod2PYhn74D8XkjgnH4grHvgDARAYFQLXX3+9uPDCC424Bw8eFPof/kAABJpJQPdX3W/535YtW/jpQI8XO/+BFg6Jg0ADCPh2+Qc/+IF4+OGHGyAZRAABEOAEBmF78Qw1J4xjEAABEAABEAABEAABEAABEAABEEgkAIc6ERSCgQAIgAAIgAAIgAAIgAAIgAAIgAAnAIea08AxCIAACIAACIAACIAACIAACIAACCQSgEOdCArBQAAEQAAEQAAEQAAEQAAEQAAEQIATgEPNaeAYBEAABEAABEAABEAABEAABEAABBIJwKFOBIVgIAACIAACIAACIAACIAACIAACIMAJwKHmNHAMAiAAAiAAAiAAAiAAAiAAAiAAAokE4FAngkIwEAABEAABEAABEAABEAABEAABEOAE4FBzGjgGARAAARAAARAAARAAARAAARAAgUQCcKgTQSEYCIAACIAACIAACIAACIAACIAACHACcKg5DRyD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"></figure><p><strong>Output Format:</strong></p><p>Your output should convert the size given in base-10 to base-2 units which will be reported in the operating system, rounded to 2 decimal places. Make sure Leela's program outputs the base-2 Binary 3 letter code for her program's output, to help Fry understand the differences.</p> 
answer

 #include<iostream>
using namespace std;
int main()
{
    float n;
    scanf("%f",&n);
    string s;
    cin>>s;
    if(s=="ZB")
    printf("%.2f EiB",n*867.36);
    else
    printf("%.2f GiB",n*931.32);
	return 0;
}

question

 <p>Question Description:</p><p>Even if you just leave them be, they will fall to pieces all by themselves. So, someone has to protect them, right?</p><p>You find yourself playing with Thomson again in the city of Liva. As you take the eccentric little kid around, you notice something interesting about the structure of the city.</p><p>Liva can be represented as a directed graph containing  nodes. Nodes are labeled from 1 to . There is a directed edge from node  to node  if and only if &lt;.</p><p>A path between nodes  and  is defined as a sequence of edges such that you can start at , travel along all of these edges in the corresponding direction, and end at .&nbsp;</p><p>The length of a path is defined by the number of edges. A rainbow path of length  is defined as a path in the graph such that there exists at least 2 distinct colors among the set of  edges.</p><p>Thomson's favorite number is . You are curious about the following scenario: If you were to label each edge with a color, what is the minimum number of colors needed to ensure that all paths of length  or longer are rainbow paths?</p><p>Thomson wants to surprise his older brother with a map of Liva. He also wants to know a valid colouring of edges that uses the minimum number of colors. Please help him with this task!</p><p>Constraints:</p><p>2 K &lt; N 1000</p><p>Input Format:</p><p>The only line of input contains two integers  and .</p><p>Output Format:</p><p>On the first line, output , the minimum colors you need to satisfy the above requirements.</p><p>On the second line, print a valid edge colouring as an array of (1)2 integers ranging from 1 to .&nbsp;</p><p>Exactly  distinct colors should exist in the construction. Print the edges in increasing order by the start node first, then by the second node.</p><p>For example, if =4, the edge colors will correspond to this order of edges: (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)</p> 
answer

 #include<iostream>
using namespace std;
int n,k,ans,x,y,t;
int main(){
	cin>>n>>k,x=n-1;
	while(x)x/=k,++ans;
	cout<<ans<<endl;
	for(int i=1;i<n;++i){
		for(int j=i+1;j<=n;++j){
			x=i-1,y=j-1,t=0;
			while(x!=y)x/=k,y/=k,++t;
			cout<<t<<" ";
		}
	}
	return 0;
	cout<<"cin>>N>>K; register";
}

question

 <p style="text-align:justify;">Question Description:</p><p>Karter wants to celebrate his first big salary by going to restaurant. However, he needs company.</p><p>Karter has <i>n</i> friends, each friend will agree to go to the restaurant if Karter asks.&nbsp;</p><p>Each friend is characterised by the amount of money he has and the friendship factor in respect to Karter.&nbsp;</p><p>The parrot doesn't want any friend to feel poor compared to somebody else in the company (Karter doesn't count).&nbsp;</p><p>A friend feels poor if in the company there is someone who has at least <i>d</i> units of money more than he does. Also, Karter wants the total friendship factor of the members of the company to be maximum.&nbsp;</p><p>Help him invite an optimal company!</p><p style="text-align:justify;">Constraints:</p><p style="text-align:justify;">1N10<sup>5</sup></p><p style="text-align:justify;">1  D  10^9</p><p style="text-align:justify;">0M<i><sub>i</sub></i>,S<i><sub>i</sub></i>10<sup>9</sup></p><p style="text-align:justify;">Input Format:</p><p>The first line of the input contains two space-separated integers, <i>n</i> and <i>d</i> the number of Karter's friends and the minimum difference between the amount of money in order to feel poor, respectively.</p><p>Next <i>n</i> lines contain the descriptions of Karter's friends, the (<i>i</i>+1)-th line contains the description of the <i>i</i>-th friend of type <i>m<sub>i</sub></i>, <i>s<sub>i</sub></i> the amount of money and the friendship factor, respectively.</p><p style="text-align:justify;">Output Format:</p><p>Print the maximum total friendship factir that can be reached.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
long long c,d,i,n,k,j;
pair<int,int>a[100005];
int main(){
cin>>n>>d;
for(i=0;i<n;i++)cin>>a[i].first>>a[i].second;
sort(a,a+n);
for(i=0;i<n;i++){
if(a[i].first-a[j].first<d){k+=a[i].second;c=max(c,k);}else{
k-=a[j++].second;i--;
}
}
cout<<c;
}

question

 <p>Question description</p><p>Moving ahead, Gudi now enters a room where the floor is divided into <i>N</i> x <i>M</i> square tiles, forming a grid with <i>N</i> rows and <i>M</i> columns.<br>Each square in the grid contains a number of Magical Orbs that Gudi has to absorb if she steps on it. Each Orb increases her Kii power, which is needed to fight the demons. Gudi enters the room on (<strong>1</strong>, <strong>1</strong>) with Zero Kii power and has to makes her way to the exit gate on (<i>N</i>, <i>M</i>), absorbing the Orbs on the way. From the current cell, she can move only to the adjacent cell in East, South or South-East direction i.e. from (i, j) to either (i, j+1) , (i+1, j) or (i+1, j+1).<br>However, her capacity for the Orbs is limited. If she absorbs more than <i>K</i> Orbs, she will explode with the large amount of Kii energy! Help her find a way to absorb as any many Orbs as she can, without exploding.</p><p><strong>Constraints</strong>:<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>T</mi><mo></mo><mn>10</mn></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo>,</mo><mi>M</mi><mo></mo><mn>100</mn></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>K</mi><mo></mo><mn>500</mn></math><br>1  Values in the Grid  50</p><p>&nbsp;</p><p><strong>Input</strong><br>The first line contains <i>T</i>. <i>T</i> testcases follow.<br>First line of each testcase contains 3 space-separated integers, <i>N</i>, <i>M</i>, <i>K</i>.<br>Each of the following <i>N</i> lines contain <i>M</i> space-separated integers, describing the grid.</p><p><strong>Output</strong><br>Print the maximum number of Orbs that she can absorb without exploding or "-1" (without the quotes) if it can not be done i.e. if there does not exist such a path. Print the answer to each testcase in a new line.</p> 
answer

 #include<bits/stdc++.h>
 
using namespace std;
 
int n,m,k;
int A[101][101];
bool dp[101][101][501];
 
int solve(){
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			for(int l=0;l<=500;l++){
				dp[i][j][l]=false;
			}
		}
	}
	dp[0][0][0]=true;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int l=0;l<=500;l++){
				if(dp[i-1][j-1][l] || dp[i-1][j][l] || dp[i][j-1][l]){
					int t=l+A[i][j];
					if(t<=500){
						dp[i][j][t]=true;
					}
				}
			}
		}
	}
	int ans=-1;
	for(int i=1;i<=k;i++){
		if(dp[n][m][i]){
			ans=max(ans,i);
		}
	}
	return ans;
}
 
int main(){
	int t;
	cin>>t;
	while(t--){
		cin>>n>>m>>k;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin>>A[i][j];
			}
		}	
		if(A[0][0]>k || A[n-1][m-1]>k){
			cout<<-1<<endl; continue;
		}
		int ans=solve();
		cout<<ans<<endl;
	}
	
	return 0;
}

question

 <p><strong>Question description</strong></p><p>Today, Vasya has decided to go to the Shopping Centre to buy some stuff for the upcoming College Farewell. On reaching the place, he found a fascinating shop that has an unlimited quantity of each item they sell. The shop has <i>N</i> different types of items. However, here Vasya has a fixed budget and can buy a maximum of <i>K</i> items. He can buy any amount of items&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo></mo><mn>1</mn></math>&nbsp;and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo></mo><mi>K</mi></math>.</p><p>He can buy an arbitrary quantity of each item. There is <strong>no restriction</strong> on different items having different quantities. Now, Vasya wonders the number of different ways in which he can shop today. Two ways are considered different if the quantity of at least <i>1</i> of the items purchased is different. Vasya finds this task too hard to complete and requires your help. You need to find the answer and print it. As the answer may be large, print it <strong>Modulo</strong>&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></math>.</p><p><strong>Constraints</strong>:</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo></mo><mn>1000</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>K</mi><mo></mo><mn>1000</mn></math></p><p><strong>Input Format</strong>:</p><p>The first and only line of input contains <i>2</i> integers <i>N</i> and <i>K</i>.</p><p><strong>Output Format</strong>:</p><p>Print the required answer on a single line.</p> 
answer

 #include<bits/stdc++.h>
#define LIM (1000000007)
using namespace std;
void solve(){}
int N,K,dp[1001][1001];
void procedure()
{
	for(int i=0;i<=N;i++)
	dp[0][i] = 1;
	for(int i=1;i<=N;i++)
	{
		int sum = dp[0][i-1];
		for(int j=1;j<=K;j++)
		{
			sum += dp[j][i-1];
			if(sum>=LIM)
			sum -= LIM;
			dp[j][i] = sum;
		}
	}
	int ans = 0;
	for(int i=1;i<=K;i++)
	{
		ans += dp[i][N];
		if(ans>=LIM)
		ans -= LIM;
	}
	cout<<ans<<endl;
}
int main()
{
	cin>>N>>K;
	procedure();
	return 0;
}

question

 <p><strong>Question description</strong></p><p>One more nightmare... This time you got into a maze.</p><p>The maze is described by two poly lines. Each of them has <strong>N + 1</strong> points. The points of the first poly line are: <strong>(x<sub>0</sub>, y<sub>0</sub>)</strong>, <strong>(x<sub>2</sub>, y<sub>2</sub>)</strong>, ... , <strong>(x<sub>N</sub>, y<sub>N</sub>)</strong>. The points of the second poly line are <strong>(x<sub>0</sub>, y<sub>0</sub> + H)</strong>, <strong>(x<sub>2</sub>, y<sub>2</sub> + H)</strong>, ... , <strong>(x<sub>N</sub>, y<sub>N</sub> + H)</strong>.</p><p>The entrance to the maze is a segment <strong>(x<sub>0</sub>, y<sub>0</sub>)</strong> - <strong>(x<sub>0</sub>, y<sub>0</sub> + H)</strong> and the exit is a segment <strong>(x<sub>0</sub>, y<sub>0</sub>)</strong> - <strong>(x<sub>N</sub>, y<sub>N</sub> + H)</strong>. During your running in the maze you can be in any point inside the maze.</p><p>The faster you go through the maze - the more chances to survive you have. You know description of the the maze. Find the length of the shortest path you have to run.</p><p><strong>Constraints</strong></p><ul><li>1 &lt;= N &lt;= 100</li><li>|x<sub>i</sub>|, |y<sub>i</sub>|, H &lt;= 10<sup>4</sup></li><li>x<sub>0</sub> &lt; x<sub>1</sub> &lt; ... &lt; x<sub>N</sub></li></ul><p><strong>Input Format</strong><br>The first line contains one integer <strong>N</strong>.<br>The following <strong>N + 1</strong> lines contains 2 space-separated integers each - description of the first poly line.<br>The last line contains one integer <strong>H</strong>.</p><p><strong>Output Format</strong><br>Output one real number with exactly 10 digits after dot - the shortest distance you have to cover.</p> 
answer

 #include<bits/stdc++.h>
 
#define eps 1e-9
using namespace std;
 
int n;
double x[200],y[200],H;
double dist[200][200];
 
double gd(double x1,double y1,double x2,double y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
 
bool check(int l,int r,double Y)
{
	for (int i=l;i<=r;i++)
		if (Y<y[i]-eps||Y>y[i]+H+eps)
			return false;
	return true;
}
 
bool valid(double x1,double y1,double x2,double y2,int l,int r)
{
	for (int i=l;i<=r;i++)
	{
		double cx=x[i];
		double qy=(cx-x1)*(y2-y1)/(x2-x1)+y1;
		if (qy<y[i]-eps||qy>y[i]+H+eps)
			return false;
	}
	return true;
}
 
int main(){
	
cin>>n;
for (int i=0;i<=n;i++)
{
	cin>>x[i]>>y[i];
}
cin>>H;
 
 
for (int i=0;i<=n;i++)
	dist[i][0]=dist[i][1]=1e9;
 
dist[0][0]=dist[0][1]=0;
 
for (int i=1;i<=n;i++)
{
	if (check(0,i-1,y[i]))
		dist[i][0]=min(dist[i][0],x[i]-x[0]);
	if (check(0,i-1,y[i]+H))
		dist[i][1]=min(dist[i][1],x[i]-x[0]);
}
 
for (int i=0;i<n;i++)
	for (int j=0;j<=1;j++)
		for (int q=i+1;q<=n;q++)
			for (int w=0;w<=1;w++)
			{
				double x1,y1,x2,y2;
				
				x1=x[i];
				y1=y[i]+H*j;
				x2=x[q];
				y2=y[q]+H*w;
				if (valid(x1,y1,x2,y2,i+1,q-1))
					dist[q][w]=min(dist[q][w],dist[i][j]+gd(x1,y1,x2,y2));
			}
			
double ans=1e9;
for (int i=0;i<=n;i++)
{
	if (check(i+1,n,y[i]))
		ans=min(ans,dist[i][0]+x[n]-x[i]);
	if (check(i+1,n,y[i]+H))
		ans=min(ans,dist[i][1]+x[n]-x[i]);
}
 
cout.precision(10);
 
cout<<fixed<<ans<<endl;
 
return 0;}

question

 <p><strong>Question description</strong></p><p>Consider a grid with <i>N</i> rows and <i>M</i> columns, where each cell has some integer value written in it. Every cell is connected to every side adjacent cell via an undirected edge. The cost of an edge <i>e</i> connecting any two cells with value <i>a</i> and <i>b</i> is&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mi>e</mi></msub><mo>=</mo><mi>a</mi><mo></mo><mi>b</mi></math>. (Here&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo></mo></math>&nbsp;denotes bitwise xor of two the integers <i>a </i>and <i>b</i>)</p><p>We define a good trip between two cells&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math>and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>2</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></math>&nbsp;as a trip starting at cell&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math>&nbsp;and ending at cell&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>2</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></math>&nbsp;while visiting every cell of the grid at least once.</p><p>There is a cost associated with every good trip. Let's say, for a given edge <i>e</i>, you travel that edge&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>e</mi></msub></math>&nbsp;times. Then the cost of the trip is:</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true" scriptlevel="0"><munder><mo></mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal"></mi><mi>e</mi></mrow></munder><mrow class="MJX-TeXAtom-ORD"><mstyle scriptlevel="0"><mrow class="MJX-TeXAtom-ORD"><mo maxsize="2.470em" minsize="2.470em">(</mo></mrow></mstyle><msub><mi>C</mi><mi>e</mi></msub><mo></mo><mstyle scriptlevel="0"><mrow class="MJX-TeXAtom-OPEN"><mo maxsize="2.470em" minsize="2.470em"></mo></mrow></mstyle><mfrac><msub><mi>T</mi><mi>e</mi></msub><mn>2</mn></mfrac><mstyle scriptlevel="0"><mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="2.470em" minsize="2.470em"></mo></mrow></mstyle><mstyle scriptlevel="0"><mrow class="MJX-TeXAtom-ORD"><mo maxsize="2.470em" minsize="2.470em">)</mo></mrow></mstyle></mrow></mstyle></math></p><p>Here,&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle scriptlevel="0"><mrow class="MJX-TeXAtom-ORD"><mo maxsize="1.623em" minsize="1.623em"></mo></mrow></mstyle><mfrac><msub><mi>T</mi><mi>e</mi></msub><mn>2</mn></mfrac><mstyle scriptlevel="0"><mrow class="MJX-TeXAtom-ORD"><mo maxsize="1.623em" minsize="1.623em"></mo></mrow></mstyle></math>&nbsp;is the ceiling of the result of division of&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>e</mi></msub></math>&nbsp;by 2</p><p>For the given starting cell&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math>&nbsp;and ending cell&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>2</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></math>, you have to find the minimum cost of a good trip.</p><p><strong>Constraints</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>T</mi><mo></mo><mn>10</mn></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo></mo><mi>M</mi><mo></mo><msup><mn>10</mn><mn>5</mn></msup></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>r</mi><mn>2</mn></msub><mo></mo><mi>N</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo></mo><mi>M</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo><mo></mo><msup><mn>10</mn><mn>4</mn></msup></math></p><p>where&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></math>&nbsp;denotes the integer in the given grid at cell&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></math>.</p><p>&nbsp;</p><p><strong>Input Format</strong></p><p>The first line will consist of the integer <i>T</i> denoting the number of test cases.</p><p>For each of the <i>T</i> test cases, the first line will consist of two integers <i>N</i> and <i>M</i>, denoting the number of rows and columns of the grid respectively.</p><p>The second line will consist of four integers,&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>r</mi><mn>1</mn></msub><msub><mi>c</mi><mn>1</mn></msub><msub><mi>r</mi><mn>2</mn></msub><msub><mi>c</mi><mn>2</mn></msub></math>, denoting the coordinates&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math>&nbsp;of the starting cell and&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>r</mi><mn>2</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></math>&nbsp;of the ending cell.</p><p>Then, <i>N</i> lines will follow, each containing <i>M </i>integers, denoting the values in the grid, such that the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>j</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;value in the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;row will denote the number in the cell&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></math>&nbsp;of the grid.</p><p><strong>Output Format</strong></p><p>For each of the <i>T</i> test cases, output a single integer, denoting the minimum cost of a good trip.</p> 
answer

 #include<stdio.h>
#include<stdlib.h>
#include<limits.h>
 
struct node
{
	int ve,w;
	struct node *next;
};
struct que
{
	int w,ve;
};
struct node *createlink(int vertex,struct node *ptr,int we)
{
	struct node *temp=(struct node *)malloc(sizeof(struct node));
	temp->ve=vertex;
	temp->next=NULL;
	temp->w=we;
	if(ptr==NULL)
	return temp;
	else
	{
		ptr->next=temp;
		return temp;
	}
 
}
void heapify(struct que *a,int n,int i,int *index)
{
	int l=2*i,r=2*i+1,smallest=i;
	struct que temp;
	if(l<=n&&a[l].w<a[smallest].w)
	smallest=l;
	if(r<=n&&a[r].w<a[smallest].w)
	smallest=r;
	if(smallest!=i)
	{
		temp=a[smallest];
		a[smallest]=a[i];
		a[i]=temp;
		index[a[i].ve]=i;
		index[a[smallest].ve]=smallest;
		heapify(a,n,smallest,index);
 
 
	}
}
int heapdeletekey(struct que *a,int n,int *index)
{
	struct que temp;
	temp=a[n];
	a[n]=a[1];
	a[1]=temp;
	index[a[1].ve]=1;
	index[a[n].ve]=n;
	n=n-1;
	heapify(a,n,1,index);
	return n;
}
int minprims(int sv,int n,struct node **a)
{
	int index[n+1],i,sum=0,l,aa=sv,k=n;
	struct que q[n+1],temp;
	struct node *t=a[sv];
	int *visited=(int *)calloc(n+1,sizeof(int));
	for(i=1;i<=n;i++)
	{
		q[i].w=INT_MAX;
		q[i].ve=i;
		index[i]=i;
 
	}
	for(i=0;i<n;i++)
	{
		visited[sv]=1;
		while(t)
        {
			if(t->w<q[index[t->ve]].w&&visited[t->ve]==0)
			{
				l=index[t->ve];
				q[l].w=t->w;
				while(l>1&&q[l/2].w>q[l].w)
				{
                  temp=q[l/2];
				  q[l/2]=q[l];
				  q[l]=temp;
				  index[q[l].ve]=l;
				  index[q[l/2].ve]=l/2;
				  l=l/2;
 
 
				}
			}
			t=t->next;
		}
		sv=q[1].ve;
		t=a[sv];
		k=heapdeletekey(q,k,index);
 
	}
	q[index[aa]].w=0;
	for(i=1;i<=n;i++)
	sum+=q[i].w;
	return sum;
 
}
int main()
{
	int i,t,n,m,r1,r2,c1,c2,j,k,u,v,l;
	scanf("%d",&t);
	for(k=0;k<t;k++)
	{
		l=0;
		scanf("%d%d",&n,&m);
		int val[n][m],arr[n][m];
		scanf("%d%d%d%d",&r1,&r2,&c1,&c2);
		struct node *a[n*m+1],*ptr[n*m+1];
		for(i=1;i<=n*m;i++)
		{
			a[i]=NULL;
			ptr[i]=NULL;
 
		}
		for(i=0;i<n;i++)
		{
			for(j=0;j<m;j++)
			{
				scanf("%d",&val[i][j]);
				arr[i][j]=++l;
 
			}
 
		}
		for(i=0;i<n;i++)
		{
			for(j=0;j<m-1;j++)
			{
             u=arr[i][j];
			 v=arr[i][j+1];
			 ptr[u]=createlink(v,ptr[u],val[i][j]^val[i][j+1]);
			 if(a[u]==NULL)
			 a[u]=ptr[u];
			 ptr[v]=createlink(u,ptr[v],val[i][j]^val[i][j+1]);
			 if(a[v]==NULL)
			 a[v]=ptr[v];
 
		    }
 
		}		
      for(i=0;i<m;i++)
		{
			for(j=0;j<n-1;j++)
			{
             u=arr[j][i];
			 v=arr[j+1][i];
			 ptr[u]=createlink(v,ptr[u],val[j][i]^val[j+1][i]);
			 if(a[u]==NULL)
			 a[u]=ptr[u];
			 ptr[v]=createlink(u,ptr[v],val[j][i]^val[j+1][i]);
			 if(a[v]==NULL)
			 a[v]=ptr[v];
 
		    }
 
		}
		printf("%d\n",minprims(1,n*m,a));
 
	}
	return 0;
}

question

 <p><strong>Question description</strong></p><p>You are given a graph in the form of a matrix of size&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi><mo></mo><mi>M</mi></math>&nbsp;containing <strong>'#' and '.'</strong>.All the cells containing <strong>'#'</strong> are nodes of the graph and two nodes are considered to be connected if they are present at the <strong>top, left, right, or bottom</strong> of each other. Initially, the graph is connected.</p><p>Write a program to determine the minimum number of nodes that need to be deleted from the graph in order to break it into two unconnected graphs.<br><strong>Constraints</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>T</mi><mo></mo><mn>10</mn></math>&nbsp;<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo>,</mo><mi>M</mi><mo></mo><mn>50</mn></math></p><p><strong>Input format</strong></p><ul><li>First line: <i><strong>T</strong></i> (number of test cases)</li><li>First line in each test case: Two space-separated integers <i><strong>N</strong></i> and <i><strong>M</strong></i></li><li>Next <i><strong>N</strong></i> lines in each test case: <i><strong>M</strong></i> space-separated characters, each '.' or '#' as described in the statement.</li></ul><p><strong>Output format</strong><br>&nbsp;</p><p>For each test case, print the minimum number of nodes that need to be deleted from the graph in order to break it into two unconnected graphs. If it is not possible to divide the graph into two parts, print <strong>-1</strong>.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
int a[50][50],n,m,k;
vector<pair<int,int> > count(int i,int j){
	vector<pair<int,int> > c;
	if(i-1>=0)if(a[i-1][j])c.push_back({-1,0});
	if(i+1<n)if(a[i+1][j])c.push_back({1,0});
	if(j-1>=0)if(a[i][j-1])c.push_back({0,-1});
	if(j+1<m)if(a[i][j+1])c.push_back({0,1});
	return c;
}
void dfs(int i, int j,vector<vector<int> > & vis){
	if(i<0||j<0||i>n||j>m)return;
	if(vis[i][j]||!a[i][j])return;
	k++;
	vis[i][j]=1;
	dfs(i+1,j,vis);
	dfs(i-1,j,vis);
	dfs(i,j+1,vis);
	dfs(i,j-1,vis);
}
int check(){
	int c=0;
	vector<vector<int> > vis(51,vector<int>(51,0));
	vector<int> v;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(!vis[i][j]&&a[i][j]){
				k=0;
				dfs(i,j,vis);
				v.push_back(k);
			}
		}
	}
	if(v.size()<2)return -1;
	sort(v.begin(),v.end());
	for(int i=0;i<(int)v.size()-2;i++)c+=v[i];
	return c;
}
void solve(){
	int ans=1000000;
	cin>>n>>m;
	vector<pair<int,int> > c[n][m];
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			char c;
			cin>>c;
			if(c=='#')a[i][j]=1;
			else a[i][j]=0;
		}
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(a[i][j]){
				if(i-1>=0)if(a[i-1][j])c[i][j].push_back({-1,0});
				if(i+1<n)if(a[i+1][j])c[i][j].push_back({1,0});
				if(j-1>=0)if(a[i][j-1])c[i][j].push_back({0,-1});
				if(j+1<m)if(a[i][j+1])c[i][j].push_back({0,1});
			}
		}
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(a[i][j]&&(int)c[i][j].size()>1){
				for(pair<int,int> x: c[i][j]){
					a[i+x.first][j+x.second]=0;
				}
				int x=check();
				if(x!=-1)ans=min(ans,(int)c[i][j].size()+x);
				for(pair<int,int> x: c[i][j]){
					a[i+x.first][j+x.second]=1;
				}
				a[i][j]=0;
				x=check();
				if(x!=-1)ans=min(ans,1+x);
				a[i][j]=1;
				if(ans==1)break;
			}
		}
		if(ans==1)break;
	}
	if(ans>=1000000)ans=-1;
	cout<<ans<<endl;
}
 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int t;
	cin>>t;
	while(t--){
		solve();
	}
}

question

 <p>Question Description:</p><p>A newspaper is published in Wonderland. Its heading is <i>s</i><sub>1</sub>, it consists of lowercase Latin letters. Franklin the little Walter wants to buy several such newspapers, cut out their headings, glue them one to another in order to get one big string.</p><p>After that Walter erase several letters from this string in order to get a new word <i>s</i><sub>2</sub>. It is considered that when Franklin erases some letter, there's no whitespace formed instead of the letter.&nbsp;</p><p>That is, the string remains unbroken and it still only consists of lowercase Latin letters.</p><p>For example, the heading is "abc". If we take two such headings and glue them one to the other one, we get "abcabc". If we erase the letters on positions 1 and 5, we get a word "bcac".</p><p>Which least number of newspaper headings <i>s</i><sub>1</sub> will Franklin need to glue them, erase several letters and get word <i>s</i><sub>2</sub>?</p><p>Constraints:</p><p>1|<i>s</i><sub>1</sub>|10<sup>4</sup></p><p>1|<i>s</i><sub>2</sub>|10<sup>6</sup></p><p>&nbsp;</p><p>Input Format:</p><p>The input data contain two lines. The first line contain the heading <i>s</i><sub>1</sub>, the second line contains the word <i>s</i><sub>2</sub>.&nbsp;</p><p>The lines only consist of lowercase Latin letters.</p><p>Output Format:</p><p>If it is impossible to get the word <i>s</i><sub>2</sub> in the above-described manner, print "-1" (without the quotes). Otherwise, print the least number of newspaper headings <i>s</i><sub>1</sub>, which Franklin will need to receive the word <i>s</i><sub>2</sub>.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
set<int>g[26];
char s1[10020];
char s2[1000020];
int p=-1,z=1;
int main()
{
	cin>>s1>>s2;
	for(int i=0;s1[i];i++)
		g[s1[i]-'a'].insert(i);
	for(int i=0;s2[i];i++)
	{
		if(g[s2[i]-'a'].empty())
			return cout<<-1,0;
		if(g[s2[i]-'a'].upper_bound(p)==g[s2[i]-'a'].end())
			p=-1,z++;			
		p=*g[s2[i]-'a'].upper_bound(p);
	}
	cout<<z;
}

question

 <p><strong>Question description</strong></p><p>There are&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;aeroplanes scheduled for departure from a runway all arriving at the same destination. All the aeroplanes will depart one by one in the order mentioned which is given by the array&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math>&nbsp;such that the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;element of the array i.e&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub></math>&nbsp;gives the constant speed of the&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;aeroplane. Aeroplane will maintain this speed throughout its journey. Also, there are only two elevations available for the aeroplanes currently i.e only two heights are permitted for the aeroplanes and for one particular elevation all the aeroplanes must be in a single straight line. Also an aeroplane&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math> will be happy only if all the aeroplanes in its elevation and ahead of it are moving at a speed greater than or equal to its speed because only then it wouldnt have to slow its speed during its course of journey. Schedule the aeroplanes so that the number of happy aeroplanes are maximised. Compute this number. (Consider no collision/overtake during the entire journey and assume the source to destination distance to be very very long)</p><p><strong>INPUT FORMAT</strong></p><ul><li>First line consists of a single integer&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math><strong>&nbsp;</strong>denoting the number of aeroplanes</li><li>Next line consists of&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>&nbsp;space separated integers with&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;integer denoting&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub></math>&nbsp;, the speed of&nbsp;<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mi>h</mi></mrow></msup></math>&nbsp;aeroplane</li></ul><p><strong>OUTPUT FORMAT</strong></p><ul><li>Print a single integer denoting the maximum number of happy aeroplanes that can be obtained by some scheduling</li></ul><p><strong>CONSTRAINTS</strong></p><ul><li><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo></mo><mn>5000</mn></math></li><li><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><msub><mi>S</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo></mo><msup><mn>10</mn><mn>9</mn></msup></math></li></ul><p><strong>SUBTASKS</strong></p><ul><li><strong>For 20 Points :&nbsp;</strong><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo></mo><mi>N</mi><mo>,</mo><msub><mi>S</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo></mo><mn>100</mn></math></li><li><strong>For 80 Points : Original Constraints</strong></li></ul><p><strong>Sample Input</strong></p><p>6
</p><p>2 3 5 4 1 9</p><p><strong>Sample Output</strong></p><p>4</p><p>&nbsp;</p><p><strong>Explanation</strong></p><p>One possible optimal shceduling is : Schedule first and second aeroplanes in lane 1. Clearly, first one is happy. Schedule third , fourth , fifth and sixth aeroplanes in lane 2. The third, fourth and fifth aeroplanes are happy. So the final ordering :&nbsp;</p><p>Lane 1 :=&nbsp; 2 3</p><p>Lane 2 :=&nbsp; 5 4 1 9</p><p>In the above ordering, for lane 1 aeroplane with speed 2 is ahead of aeroplane with speed 3. Similarly for lane 2 also.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define sjf for(i=0;i<n;i++)
int main()
{
	int n;
	cin>>n;
	int arr[n];
	for(int i=0;i<n;i++)
	cin>>arr[i];
	int m;
	int dp[n+1];
	memset(dp,-1,sizeof(dp));
	dp[0] = INT_MAX;
	int ans = 0,ind = 0;
	m = INT_MAX;
	for(int i=0;i<n;i++)
	{
		if(arr[i]<=m)
		{
			m = arr[i];
			ans ++;
			continue;
		}
		for(int j=ind;j>-1;j--)
		{
			if(dp[j]==arr[i])
			dp[j+1] = dp[j];
			else if(dp[j]>arr[i])
			dp[j+1] = max(dp[j+1],arr[i]);
		}
		if(dp[ind+1]!=-1)
		ind++;
	}
	cout<<ans+ind<<endl;
	return 0;
}

question

 <p style="text-align:justify;">Question Description:</p><p>Player A is playing a game with Player B. The rules are simple. Players have to say words in turns. You cannot say a word which was already said. Player A starts. The Ball which can't say a new word loses.</p><p>You're given two lists of words familiar to Player A and Player B. Can you determine who wins the game, if both play optimally?</p><p style="text-align:justify;">Constraints:</p><p style="text-align:justify;">1<i>n</i>,<i>m</i>10<sup>3</sup></p><p style="text-align:justify;">Input Format:</p><p>The first input line contains two integers <i>n</i> and <i>m</i> number of words Player A and Player B know, respectively.</p><p>Then <i>n</i> strings follow, one per line&nbsp;words familiar to Player A.</p><p>Then <i>m</i> strings follow, one per line&nbsp;words familiar to Player B.</p><p>Note that one Ball cannot know a word more than once (strings are unique), but some words can be known by both players.</p><p>Each word is non-empty and consists of no more than 500 lowercase English alphabet letters.</p><p style="text-align:justify;">Output Format:</p><p style="text-align:justify;">In a single line of print the answer&nbsp;"YES" if Player A wins and "NO" otherwise. Both Players play optimally.</p> 
answer

 #include<bits/stdc++.h>
using namespace std;
#define sjfhhf cin>>st,mp.insert(st);
int n,m,i;
string s;
set<string> S;
int main(){
cin>>n>>m;
for(i=0;i<n+m;i++)cin>>s,S.insert(s);
i=n+m-S.size();
m-=i%2;
cout<<(n>m?"YES":"NO");
}
